// File generated by dotnet-combine at 2023-05-28__15_33_27

using CodinGame_Spring_Challenge_2023;
using System;
using System.Collections.Generic;
using System.Linq;




public class Base : IHaveCellIndex
{
    public int CellIndex { get; set; }
}


public class Cell
{
    public CellType CellType { get; set; }
    public int Resources { get; set; }
    
    public int[] Neighbours { get; set; } = new int[6];

    public int NumAnts => NumMyAnts + NumEnemyAnts;
    public int NumMyAnts { get; set; }
    public int NumEnemyAnts { get; set; }
}

public enum CellType
{
    Empty = 0,
    Eggs = 1,
    Crystal = 2
}


public class Crystal : IHaveCellIndex
{
    public int CellIndex { get; set; }
}


public class Egg : IHaveCellIndex
{
    public int CellIndex { get; set; }
}


public class GameActions
{
    private const bool ShowDebug = true;
    
    private List<string> Actions { get; set; } = new List<string>();

    public GameActions()
    {
    }

    public void FlushMoves()
    {
        if (Actions.Count == 0)
        {
            Wait();
        }
        
        Console.WriteLine(string.Join(";", Actions));
        
        Actions.Clear();
    }
    
    // WAIT | LINE <sourceIdx> <targetIdx> <strength> | BEACON <cellIdx> <strength> | MESSAGE <text>
    public void Wait()
    {
        Actions.Add("WAIT");
    }
        
    public void Line(int sourceIdx, int targetIdx, int strength, string message = null)
    {
        DebugMessage(message);
        Actions.Add($"LINE {sourceIdx} {targetIdx} {strength}");
    }
        
    public void Beacon(int cellIdx, int strength, string message = null)
    {
        DebugMessage(message);
        Actions.Add($"BEACON {cellIdx} {strength}");
    }
        
    public void Message(string text)
    {
        Actions.Add($"MESSAGE {text}");
    }

    public void DebugMessage(string message)
    {
        if (!ShowDebug || message == null) return;
        
        Message(message);
    }
}


public class GameState
{
    public int NumberOfCells { get; set; }
    public int NumberOfBasesPerPlayer { get; set; }
    
    public List<Base> MyBases { get; set; } = new List<Base>();
    public List<Base> EnemyBases { get; set; } = new List<Base>();
    public List<Cell> Cells { get; set; } = new List<Cell>();
    public List<Crystal> Crystals { get; set; } = new List<Crystal>();
    public List<Egg> Eggs { get; set; } = new List<Egg>();
    
    public List<int> MyBaseLocations { get; set; } = new List<int>();
    public List<int> EnemyBaseLocations { get; set; } = new List<int>();
    public List<int> CrystalLocations { get; set; } = new List<int>();
    public List<int> EggLocations { get; set; } = new List<int>();
    public List<int> MyCrystalLocations { get; set; } = new List<int>();
    public List<int> EnemyCrystalLocations { get; set; } = new List<int>();
    public List<int> MyEggLocations { get; set; } = new List<int>();
    public List<int> EnemyEggLocations { get; set; } = new List<int>();
    public List<int> ContestedCrystalLocations { get; set; } = new List<int>();
    public List<int> ContestedEggLocations { get; set; } = new List<int>();
}


public static class GameStateReader
{
    private static void ReadNumberOfCells(GameState gameState)
    {
        // amount of hexagonal cells in this map
        gameState.NumberOfCells = int.Parse(Console.ReadLine());
    }

    private static void ReadInitialCellState(GameState gameState)
    {
        for (var i = 0; i < gameState.NumberOfCells; i++)
        {
            var inputs = Console.ReadLine().Split(' ');
            var type = (CellType)int.Parse(inputs[0]); // 0 for empty, 1 for eggs, 2 for crystal
            var initialResources = int.Parse(inputs[1]); // the initial amount of eggs/crystals on this cell
            var neigh0 = int.Parse(inputs[2]); // the index of the neighbouring cell for each direction
            var neigh1 = int.Parse(inputs[3]);
            var neigh2 = int.Parse(inputs[4]);
            var neigh3 = int.Parse(inputs[5]);
            var neigh4 = int.Parse(inputs[6]);
            var neigh5 = int.Parse(inputs[7]);

            gameState.Cells.Add(new Cell
            {
                CellType = type,
                Resources = initialResources,
                Neighbours = new[] { neigh0, neigh1, neigh2, neigh3, neigh4, neigh5 }
            });

            if (type == CellType.Crystal)
            {
                gameState.Crystals.Add(new Crystal { CellIndex = i });
                gameState.CrystalLocations.Add(i);
            }

            if (type == CellType.Eggs)
            {
                gameState.Eggs.Add(new Egg { CellIndex = i });
                gameState.EggLocations.Add(i);
            }
        }
    }

    private static void ReadNumberOfBases(GameState gameState)
    {
        gameState.NumberOfBasesPerPlayer = int.Parse(Console.ReadLine());
    }

    private static void ReadBases(GameState gameState, ICollection<Base> bases, ICollection<int> baseLocations)
    {
        var inputs = Console.ReadLine().Split(' ');
        for (var i = 0; i < gameState.NumberOfBasesPerPlayer; i++)
        {
            var baseIndex = int.Parse(inputs[i]);
            bases.Add(new Base { CellIndex = baseIndex });
            baseLocations.Add(baseIndex);
        }
    }

    public static GameState ReadInitialState()
    {
        var gameState = new GameState();
        ReadNumberOfCells(gameState);
        ReadInitialCellState(gameState);
        ReadNumberOfBases(gameState);
        ReadBases(gameState, gameState.MyBases, gameState.MyBaseLocations);
        ReadBases(gameState, gameState.EnemyBases, gameState.EnemyBaseLocations);

        return gameState;
    }

    public static void ReadStateUpdate(GameState gameState)
    {
        for (var i = 0; i < gameState.NumberOfCells; i++)
        {
            var inputs = Console.ReadLine().Split(' ');
            var resources = int.Parse(inputs[0]); // the current amount of eggs/crystals on this cell
            var myAnts = int.Parse(inputs[1]); // the amount of your ants on this cell
            var oppAnts = int.Parse(inputs[2]); // the amount of opponent ants on this cell

            gameState.Cells[i].Resources = resources;
            gameState.Cells[i].NumMyAnts = myAnts;
            gameState.Cells[i].NumEnemyAnts = oppAnts;

            if (resources == 0 && gameState.CrystalLocations.Contains(i))
            {
                gameState.CrystalLocations.Remove(i);
                gameState.ContestedCrystalLocations.Remove(i);
                gameState.MyCrystalLocations.Remove(i);
                gameState.EnemyCrystalLocations.Remove(i);
                gameState.Crystals.RemoveAll(x => x.CellIndex == i);
            }

            if (resources == 0 && gameState.EggLocations.Contains(i))
            {
                gameState.EggLocations.Remove(i);
                gameState.ContestedEggLocations.Remove(i);
                gameState.MyEggLocations.Remove(i);
                gameState.EnemyEggLocations.Remove(i);
                gameState.Eggs.RemoveAll(x => x.CellIndex == i);
            }
        }
    }

    public static void DetermineOwnership(GameState gameState, PathFinder pathFinder)
    {
        var crystalContention = gameState.CrystalLocations.Select(index =>
        {
            var closestEnemyBase = pathFinder.ClosestOrDefault(index, gameState.EnemyBaseLocations);
            if (closestEnemyBase.index == -1)
            {
                return (index, isContested: true, isMine: false);
            }

            var closestMyBase = pathFinder.ClosestOrDefault(index, gameState.MyBaseLocations);
            if (closestMyBase.index == -1)
            {
                return (index, isContested: true, isMine: false);
            }

            return (index, isContested: closestEnemyBase.dist == closestMyBase.dist,
                isMine: closestMyBase.dist < closestEnemyBase.dist);
        });
        
        foreach (var (index, isContested, isMine) in crystalContention)
        {
            if (isContested)
            {
                gameState.ContestedCrystalLocations.Add(index);
            }
            else if (isMine)
            {
                gameState.MyCrystalLocations.Add(index);
            }
            else
            {
                gameState.EnemyCrystalLocations.Add(index);
            }
        }
        
        var eggContention = gameState.EggLocations.Select(index =>
        {
            var closestEnemyBase = pathFinder.ClosestOrDefault(index, gameState.EnemyBaseLocations);
            if (closestEnemyBase.index == -1)
            {
                return (index, isContested: true, isMine: false);
            }

            var closestMyBase = pathFinder.ClosestOrDefault(index, gameState.MyBaseLocations);
            if (closestMyBase.index == -1)
            {
                return (index, isContested: true, isMine: false);
            }

            return (index, isContested: closestEnemyBase.dist == closestMyBase.dist,
                isMine: closestMyBase.dist < closestEnemyBase.dist);
        });
        
        foreach (var (index, isContested, isMine) in eggContention)
        {
            if (isContested)
            {
                gameState.ContestedEggLocations.Add(index);
            }
            else if (isMine)
            {
                gameState.MyEggLocations.Add(index);
            }
            else
            {
                gameState.EnemyEggLocations.Add(index);
            }
        }
    }
}

public interface IHaveCellIndex
{
    int CellIndex { get; set; }
}


public class PathFinder
{
    private readonly int _numCells;

    private readonly List<Dictionary<int, (int dir, int dist)>> _cellPathMap = new List<Dictionary<int, (int dir, int dist)>>();

    private bool _fullyExpanded;
    
    private Action _onPathExpansionComplete;

    public PathFinder(GameState gameState)
    {
        _numCells = gameState.NumberOfCells;
        _onPathExpansionComplete = () => {};

        BuildPathInfo(gameState);
    }

    public PathFinder(List<Dictionary<int, (int dir, int dist)>> cellPathMap, int numCells)
    {
        _numCells = numCells;
        _cellPathMap = cellPathMap;
        _onPathExpansionComplete = () => {};
    }

    public void OnPathExpansionComplete(Action action)
    {
        _onPathExpansionComplete = action;
    }

    public bool ExpandPathKnowledge()
    {
        if (_fullyExpanded) return true;

        var newPathsFound = new List<(int from, int fromDir, int to, int toDir, int dist)>();

        for (var i = 0; i < _numCells; ++i)
        {
            var pathsForCell = _cellPathMap[i];

            foreach (var knownCellIndex in pathsForCell.Keys)
            {
                var pathToKnownCell = pathsForCell[knownCellIndex];
                var pathsForKnownCell = _cellPathMap[knownCellIndex];
                foreach (var otherCellIndex in pathsForKnownCell.Keys)
                {
                    if (i == otherCellIndex) continue;

                    var possibleDistViaKnownCell = pathToKnownCell.dist + pathsForKnownCell[otherCellIndex].dist;

                    if (pathsForCell.TryGetValue(otherCellIndex, out var myCurrentBestPathToOtherCell))
                    {
                        if (myCurrentBestPathToOtherCell.dist <= possibleDistViaKnownCell)
                        {
                            continue;
                        }
                    }

                    //We are new here or simply have a better path!
                    var pathsForOtherCell = _cellPathMap[otherCellIndex];
                    newPathsFound.Add((i, pathToKnownCell.dir, otherCellIndex, pathsForOtherCell[knownCellIndex].dir,
                        possibleDistViaKnownCell));
                }
            }
        }

        if (newPathsFound.Count == 0)
        {
            _fullyExpanded = true;
            _onPathExpansionComplete();
            return true;
        }

        foreach (var newPath in newPathsFound)
        {
            _cellPathMap[newPath.from][newPath.to] = (newPath.fromDir, newPath.dist);
            _cellPathMap[newPath.to][newPath.from] = (newPath.toDir, newPath.dist);
        }

        return false;
    }


    private void BuildPathInfo(GameState gameState)
    {
        for (var i = 0; i < gameState.NumberOfCells; ++i)
        {
            var pathsForCell = new Dictionary<int, (int dir, int dist)>();
            _cellPathMap.Add(pathsForCell);

            var cell = gameState.Cells[i];
            for (var dir = 0; dir < 6; ++dir)
            {
                var neighbourIndex = cell.Neighbours[dir];
                if (neighbourIndex == -1) continue;

                pathsForCell.Add(neighbourIndex, (dir, 1));
            }
        }
    }
    /*
    for (var i = 0; i < _gameState.NumberOfCells; ++i)
        {
            var cell = _gameState.Cells[i];
            var pathsForCell = _cellPathMap[i];

            foreach (var pathToIndex in pathsForCell.Keys)
            {
                var knownCell = _gameState.Cells[pathToIndex];
                var pathsForKnownCell = _cellPathMap[pathToIndex];
                foreach (var otherPathToIndex in pathsForCell.Keys)
                {
                    if (pathToIndex == otherPathToIndex) continue;

                    if (!pathsForKnownCell.ContainsKey(otherPathToIndex))
                    {
                        pathsForKnownCell[otherPathToIndex] = pathsForCell[pathToIndex].
                    }   
                }
            }
        }
    }
    */

    public IOrderedEnumerable<(int index, int dist)> ClosestDistances(int fromIndex, IEnumerable<int> toIndexList) =>
        toIndexList.Select(index => (index: index, dist: Distance(fromIndex, index))).Where((_, dist) => dist > -1)
            .OrderBy(x => x.dist);

    public (int index, int dist) ClosestOrDefault(int fromIndex, IEnumerable<int> toIndexList)
    {
        var closestDistances = ClosestDistances(fromIndex, toIndexList);
        if (closestDistances.Any())
        {
            return closestDistances.First();
        }
        
        return (-1, -1);
    }
    
    public int Distance(int fromIndex, int toIndex)
    {
        if (_cellPathMap[fromIndex].TryGetValue(toIndex, out var path))
        {
            return path.dist;
        }

        return -1;
    }
    
    public IEnumerable<int> PathTo(GameState gameState, int fromIndex, int toIndex)
    {
        if (!_cellPathMap[fromIndex].ContainsKey(toIndex))
        {
            return Enumerable.Empty<int>();
        }
        
        var path = new List<int>();
        var currentCellIndex = fromIndex;
        while (currentCellIndex != toIndex)
        {
            path.Add(currentCellIndex);
            var nextCellDir = _cellPathMap[currentCellIndex][toIndex].dir;
            currentCellIndex = gameState.Cells[currentCellIndex].Neighbours[nextCellDir];
        }

        path.Add(toIndex);
        return path;
    }
    
    public IEnumerable<int> ClosestNOf(GameState gameState, int num, params IEnumerable<int>[] indexLists)
    {
        var closest = new List<int>();
        var closestDistances = new List<int>();
        foreach (var indexList in indexLists)
        {
            foreach (var index in indexList)
            {
                var dist = Distance(gameState.MyBases[0].CellIndex, index);
                if (dist == -1) continue;

                var indexToInsertAt = closestDistances.FindIndex(d => d > dist);
                if (indexToInsertAt == -1)
                {
                    indexToInsertAt = closest.Count;
                }

                closest.Insert(indexToInsertAt, index);
                closestDistances.Insert(indexToInsertAt, dist);
            }
        }

        return closest.Take(num);
    }

    public string DebugDistances(GameState gameState)
    {
        var output = "Distances from my base: ";
        foreach (var myBase in gameState.MyBases)
        {
            var crystalDistances = ClosestDistances(myBase.CellIndex, gameState.CrystalLocations);
            foreach (var crystal in crystalDistances)
            {
                output += $"({crystal.index}, {crystal.dist}) ";
            }
        }
        
        output += " Distances from enemy base: ";
        foreach (var enemyBase in gameState.EnemyBases)
        {
            var crystalDistances = ClosestDistances(enemyBase.CellIndex, gameState.CrystalLocations);
            foreach (var crystal in crystalDistances)
            {
                output += $"({crystal.index}, {crystal.dist}) ";
            }
        }

        return output;
    }

    public string DebugPaths(GameState gameState)
    {
        var output = "Paths from my base: ";
        foreach (var myBase in gameState.MyBases)
        {
            foreach (var crystal in gameState.CrystalLocations)
            {
                var path = PathTo(gameState,myBase.CellIndex, crystal);
                output += $"(Base({myBase.CellIndex}) -> Crystal({crystal}) : ";
                foreach (var step in path)
                {
                    output += step + " ";
                }
            }
        }
        
        output += " Paths from enemy base: ";
        foreach (var enemyBase in gameState.EnemyBases)
        {
            foreach (var crystal in gameState.CrystalLocations)
            {
                var path = PathTo(gameState, enemyBase.CellIndex, crystal);
                output += $"(Base({enemyBase.CellIndex}) -> Crystal({crystal}) : ";
                foreach (var step in path)
                {
                    output += step + " ";
                }
            }
        }

        return output;
    }
}


public static class Player
{
    static void Main(string[] args)
    {
        var gameActions = new GameActions();
        var gameState = GameStateReader.ReadInitialState();
        var pathFinder = new PathFinder(gameState);
        pathFinder.OnPathExpansionComplete(() => GameStateReader.DetermineOwnership(gameState, pathFinder));
        var shortestTree = new ShortestTree(pathFinder);

        var maxLoops = 20;
        while (!pathFinder.ExpandPathKnowledge() && maxLoops-- > 0)
        {
        }

        if (maxLoops == 0)
        {
            Console.Error.WriteLine("Could not complete path map, will update each frame but may not be optimal");
        }

        // game looping
        while (true)
        {
            GameStateReader.ReadStateUpdate(gameState);
            pathFinder.ExpandPathKnowledge();

            var eggs = pathFinder.ClosestNOf(gameState, 1, gameState.MyEggLocations, gameState.ContestedEggLocations)
                .ToList();
            var crystals = pathFinder.ClosestNOf(gameState, 1, gameState.ContestedCrystalLocations,
                gameState.EnemyCrystalLocations);

            var locations = new[]
            {
                gameState.MyBaseLocations,
                gameState.MyCrystalLocations,
                crystals,
                eggs
            }.SelectMany(x => x).ToList();

            Console.Error.WriteLine(string.Join(",", locations.Select(x => x.ToString())));

            foreach (var index in ShortestTreeWalker.WalkShortestTree(gameState, pathFinder, shortestTree.GetShortestTree(locations)))
            {
                gameActions.Beacon(index, 1);
            }

            // MUST TRIM THE NODES BEFORE WE PASS IN HERE, NOT AFTER

            /*
            shortestTree.GetShortestTree(locations)
                .ToList()
                .ForEach(x =>
                {
                    var dist = pathFinder.Distance(x.fromIndex, x.toIndex);
                    var isEgg = eggs.Contains(x.toIndex) || eggs.Contains(x.fromIndex);
                    if (isEgg)
                    {
                        var strength = 3 - dist;
                        if (strength > 0)
                        {
                            gameActions.Line(x.fromIndex, x.toIndex, strength * 10);
                        }

                        return;
                    }

                    var isMyCrystal = gameState.MyCrystalLocations.Contains(x.toIndex) ||
                                      gameState.MyCrystalLocations.Contains(x.fromIndex);
                    gameActions.Line(x.fromIndex, x.toIndex, isMyCrystal ? 6 : 2);
                });
                */

            gameActions.FlushMoves();
        }
    }
}

// ShortestTree.cs
namespace CodinGame_Spring_Challenge_2023
{
    public class ShortestTree
    {
        private PathFinder _pathFinder;
        
        public ShortestTree(PathFinder pathFinder)
        {
            _pathFinder = pathFinder;
        }
        
        public IEnumerable<(int fromIndex, int toIndex)> GetShortestTree(IEnumerable<int> includeLocations)
        {
            var shortestTree = new List<(int fromIndex, int toIndex)>();
            
            var visited = new HashSet<int>();
            var unvisited = new HashSet<int>();
            foreach (var index in includeLocations)
            {
                unvisited.Add(index);
            }
            
            var currentCellIndex = 0;
            visited.Add(currentCellIndex);
            unvisited.Remove(currentCellIndex);
            
            while (unvisited.Count > 0)
            {
                var shortestPath = (fromIndex: -1, toIndex: -1, dist: int.MaxValue);
                foreach (var visitedCellIndex in visited)
                {
                    foreach (var unvisitedCellIndex in unvisited)
                    {
                        var dist = _pathFinder.Distance(unvisitedCellIndex, visitedCellIndex);
                        if (dist < 0) continue;
                        
                        if (dist < shortestPath.dist)
                        {
                            shortestPath = (visitedCellIndex, unvisitedCellIndex, dist);
                        }
                    }
                }
                
                shortestTree.Add((shortestPath.fromIndex, shortestPath.toIndex));
                
                visited.Add(shortestPath.toIndex);
                unvisited.Remove(shortestPath.toIndex);
            }
            
            return shortestTree;
        }
    }
}

// ShortestTreeWalker.cs
namespace CodinGame_Spring_Challenge_2023
{
    public static class ShortestTreeWalker
    {
        public static IEnumerable<int> WalkShortestTree(GameState gameState, PathFinder pathFinder,
            IEnumerable<(int fromIndex, int toIndex)> tree) => tree
            .SelectMany(x => pathFinder.PathTo(gameState, x.fromIndex, x.toIndex)).Distinct();
    }
}
