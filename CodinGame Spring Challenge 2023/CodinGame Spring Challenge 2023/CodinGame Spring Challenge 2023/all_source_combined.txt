// File generated by dotnet-combine at 2023-05-30__00_56_30

using CodinGame_Spring_Challenge_2023.Core;
using CodinGame_Spring_Challenge_2023.Domain;
using CodinGame_Spring_Challenge_2023.PathFinding;
using CodinGame_Spring_Challenge_2023.Strategy;
using CodinGame_Spring_Challenge_2023.Utils;
using System;
using System.Collections.Generic;
using System.Linq;



// Player.cs
namespace CodinGame_Spring_Challenge_2023{
public static class Player
{
    static void Main(string[] args)
    {
        var lastFrame = DateTime.UtcNow;
        
        var gameActions = new GameActions();
        var gameState = GameStateReader.ReadInitialState();
        var pathFinder = new PathFinder(gameState);
        var shortestTree = new ShortestTree(pathFinder);
        var mapInfo = new MapInfo(gameState, pathFinder);
        var strategyCostBenefitAdaptive = new StrategyCostBenefitAdaptive(gameState, pathFinder, shortestTree);
        var strategyAssessWinConditions = new StrategyAssessWinConditions(gameState);

        pathFinder.OnPathExpansionComplete(() =>
        {
            GameStateReader.DetermineOwnership(gameState, pathFinder);
            mapInfo.UpdateStatic();
        });

        var maxLoops = 20;
        while (!pathFinder.ExpandPathKnowledge() && maxLoops-- > 0)
        {
        }

        if (maxLoops == 0)
        {
            Console.Error.WriteLine("Could not complete path map, will update each frame but may not be optimal");
        }

        // game looping
        while (true)
        {
            GameStateReader.ReadStateUpdate(gameState);
            pathFinder.ExpandPathKnowledge();

            var locations = strategyCostBenefitAdaptive.Update(strategyAssessWinConditions.ProjectedTurnsUntilGameEnds);
            foreach (var index in locations)
            {
                gameActions.Beacon(index, 1);
            }

            strategyAssessWinConditions.Update();
            gameActions.FlushMoves();

            var frameEndTime = DateTime.UtcNow;
            var frameTime = frameEndTime - lastFrame;
            Console.Error.WriteLine($"Frame time: {frameTime.TotalMilliseconds}ms");
            lastFrame = frameEndTime;
        }
    }
}}

// Core/GameActions.cs
namespace CodinGame_Spring_Challenge_2023.Core{
public class GameActions
{
    private const bool ShowDebug = true;
    
    private List<string> Actions { get; set; } = new List<string>();

    public GameActions()
    {
    }

    public void FlushMoves()
    {
        if (Actions.Count == 0)
        {
            Wait();
        }
        
        Console.WriteLine(string.Join(";", Actions));
        
        Actions.Clear();
    }
    
    // WAIT | LINE <sourceIdx> <targetIdx> <strength> | BEACON <cellIdx> <strength> | MESSAGE <text>
    public void Wait()
    {
        Actions.Add("WAIT");
    }
        
    public void Line(int sourceIdx, int targetIdx, int strength, string message = null)
    {
        DebugMessage(message);
        Actions.Add($"LINE {sourceIdx} {targetIdx} {strength}");
    }
        
    public void Beacon(int cellIdx, int strength, string message = null)
    {
        DebugMessage(message);
        Actions.Add($"BEACON {cellIdx} {strength}");
    }
        
    public void Message(string text)
    {
        Actions.Add($"MESSAGE {text}");
    }

    public void DebugMessage(string message)
    {
        if (!ShowDebug || message == null) return;
        
        Message(message);
    }
}}

// Core/GameState.cs
namespace CodinGame_Spring_Challenge_2023.Core{
public class GameState
{
    public int NumberOfCells { get; set; }
    public int NumberOfBasesPerPlayer { get; set; }
    
    public int MyAntCount { get; set; }
    public int EnemyAntCount { get; set; }
    
    public int MyCrystalCount { get; set; }
    public int EnemyCrystalCount { get; set; }
    
    public List<Base> MyBases { get; set; } = new ();
    public List<Base> EnemyBases { get; set; } = new ();
    public List<Cell> Cells { get; set; } = new ();
    public List<Crystal> Crystals { get; set; } = new ();
    public List<Egg> Eggs { get; set; } = new ();
    
    public List<int> MyBaseLocations { get; set; } = new ();
    public List<int> EnemyBaseLocations { get; set; } = new ();
    public List<int> CrystalLocations { get; set; } = new ();
    public List<int> EggLocations { get; set; } = new ();
    public List<int> MyCrystalLocations { get; set; } = new ();
    public List<int> EnemyCrystalLocations { get; set; } = new ();
    public List<int> MyEggLocations { get; set; } = new ();
    public List<int> EnemyEggLocations { get; set; } = new ();
    public List<int> ContestedCrystalLocations { get; set; } = new ();
    public List<int> ContestedEggLocations { get; set; } = new ();

    public Dictionary<int, int> MyAntLookup { get; set; } = new ();

    public Dictionary<int, int> EnemyAntLookup { get; set; } = new ();
}}

// Core/GameStateReader.cs
namespace CodinGame_Spring_Challenge_2023.Core{
public static class GameStateReader
{
    private static void ReadNumberOfCells(GameState gameState)
    {
        // amount of hexagonal cells in this map
        gameState.NumberOfCells = int.Parse(Console.ReadLine());
    }

    private static void ReadInitialCellState(GameState gameState)
    {
        for (var i = 0; i < gameState.NumberOfCells; i++)
        {
            var inputs = Console.ReadLine().Split(' ');
            var type = (CellType)int.Parse(inputs[0]); // 0 for empty, 1 for eggs, 2 for crystal
            var initialResources = int.Parse(inputs[1]); // the initial amount of eggs/crystals on this cell
            var neigh0 = int.Parse(inputs[2]); // the index of the neighbouring cell for each direction
            var neigh1 = int.Parse(inputs[3]);
            var neigh2 = int.Parse(inputs[4]);
            var neigh3 = int.Parse(inputs[5]);
            var neigh4 = int.Parse(inputs[6]);
            var neigh5 = int.Parse(inputs[7]);

            gameState.Cells.Add(new Cell
            {
                CellType = type,
                Resources = initialResources,
                Neighbours = new[] { neigh0, neigh1, neigh2, neigh3, neigh4, neigh5 }
            });

            if (type == CellType.Crystal)
            {
                gameState.Crystals.Add(new Crystal { CellIndex = i });
                gameState.CrystalLocations.Add(i);
            }

            if (type == CellType.Eggs)
            {
                gameState.Eggs.Add(new Egg { CellIndex = i });
                gameState.EggLocations.Add(i);
            }
        }
    }

    private static void ReadNumberOfBases(GameState gameState)
    {
        gameState.NumberOfBasesPerPlayer = int.Parse(Console.ReadLine());
    }

    private static void ReadBases(GameState gameState, ICollection<Base> bases, ICollection<int> baseLocations)
    {
        var inputs = Console.ReadLine().Split(' ');
        for (var i = 0; i < gameState.NumberOfBasesPerPlayer; i++)
        {
            var baseIndex = int.Parse(inputs[i]);
            bases.Add(new Base { CellIndex = baseIndex });
            baseLocations.Add(baseIndex);
        }
    }

    public static GameState ReadInitialState()
    {
        var gameState = new GameState();
        ReadNumberOfCells(gameState);
        ReadInitialCellState(gameState);
        ReadNumberOfBases(gameState);
        ReadBases(gameState, gameState.MyBases, gameState.MyBaseLocations);
        ReadBases(gameState, gameState.EnemyBases, gameState.EnemyBaseLocations);

        return gameState;
    }

    public static void ReadStateUpdate(GameState gameState)
    {
        gameState.MyAntLookup.Clear();
        gameState.EnemyAntLookup.Clear();

        gameState.MyAntCount = 0;
        gameState.EnemyAntCount = 0;
        gameState.MyCrystalCount = 0;
        gameState.EnemyCrystalCount = 0;

        for (var i = 0; i < gameState.NumberOfCells; i++)
        {
            var inputs = Console.ReadLine().Split(' ');
            var resources = int.Parse(inputs[0]); // the current amount of eggs/crystals on this cell
            var myAnts = int.Parse(inputs[1]); // the amount of your ants on this cell
            var oppAnts = int.Parse(inputs[2]); // the amount of opponent ants on this cell

            gameState.Cells[i].Resources = resources;
            gameState.Cells[i].NumMyAnts = myAnts;
            gameState.Cells[i].NumEnemyAnts = oppAnts;

            if (resources == 0 && gameState.CrystalLocations.Contains(i))
            {
                gameState.CrystalLocations.Remove(i);
                gameState.ContestedCrystalLocations.Remove(i);
                gameState.MyCrystalLocations.Remove(i);
                gameState.EnemyCrystalLocations.Remove(i);
                gameState.Crystals.RemoveAll(x => x.CellIndex == i);
            }

            if (resources == 0 && gameState.EggLocations.Contains(i))
            {
                gameState.EggLocations.Remove(i);
                gameState.ContestedEggLocations.Remove(i);
                gameState.MyEggLocations.Remove(i);
                gameState.EnemyEggLocations.Remove(i);
                gameState.Eggs.RemoveAll(x => x.CellIndex == i);
            }

            if (myAnts > 0)
            {
                gameState.MyAntLookup[i] = myAnts;
                gameState.MyAntCount += myAnts;
            }

            if (oppAnts > 0)
            {
                gameState.EnemyAntLookup[i] = myAnts;
                gameState.EnemyAntCount += myAnts;
            }
        }
    }

    public static void DetermineOwnership(GameState gameState, PathFinder pathFinder)
    {
        var crystalContention = gameState.CrystalLocations.Select(index => pathFinder
            .ClosestOrDefault(index, gameState.EnemyBaseLocations)
            .Match(
                closestEnemyBase => pathFinder
                    .ClosestOrDefault(index, gameState.MyBaseLocations)
                    .Match(
                        closestMyBase => (index, isContested: closestEnemyBase.dist == closestMyBase.dist,
                            isMine: closestMyBase.dist < closestEnemyBase.dist),
                        _ => (index, isContested: true, isMine: false)
                    ),
                _ => (index, isContested: true, isMine: false)));

        foreach (var (index, isContested, isMine) in crystalContention)
        {
            if (isContested)
            {
                gameState.ContestedCrystalLocations.Add(index);
            }
            else if (isMine)
            {
                gameState.MyCrystalLocations.Add(index);
            }
            else
            {
                gameState.EnemyCrystalLocations.Add(index);
            }
        }

        var eggContention = gameState.EggLocations.Select(index => pathFinder
            .ClosestOrDefault(index, gameState.EnemyBaseLocations)
            .Match(
                closestEnemyBase => pathFinder
                    .ClosestOrDefault(index, gameState.MyBaseLocations)
                    .Match(
                        closestMyBase => (index, isContested: closestEnemyBase.dist == closestMyBase.dist,
                            isMine: closestMyBase.dist < closestEnemyBase.dist),
                        _ => (index, isContested: true, isMine: false)
                    ),
                _ => (index, isContested: true, isMine: false)));
        
        foreach (var (index, isContested, isMine) in eggContention)
        {
            if (isContested)
            {
                gameState.ContestedEggLocations.Add(index);
            }
            else if (isMine)
            {
                gameState.MyEggLocations.Add(index);
            }
            else
            {
                gameState.EnemyEggLocations.Add(index);
            }
        }
    }
}}

// Utils/Invalid.cs
namespace CodinGame_Spring_Challenge_2023.Utils{
public record Invalid();}

// Utils/NotFound.cs
namespace CodinGame_Spring_Challenge_2023.Utils{
public record NotFound();}

// Utils/NotFoundIndex.cs
namespace CodinGame_Spring_Challenge_2023.Utils{
public record NotFoundIndex
{
    public int Index { get; }
    
    public NotFoundIndex(int index)
    {
        Index = index;
    }
}}

// Utils/OneOf.cs
namespace CodinGame_Spring_Challenge_2023.Utils{
public class OneOf<T, U>
{
    private readonly T? _value1;
    private readonly U? _value2;
    
    public OneOf(T value)
    {
        _value1 = value;
    }
    
    public OneOf(U value)
    {
        _value2 = value;
    }
    
    public bool IsValue1 => _value1 != null;
    public bool IsValue2 => _value2 != null;
    
    public T Value1 => _value1!;
    public U Value2 => _value2!;
    
    public static implicit operator OneOf<T, U>(T value) => new (value);
    public static implicit operator OneOf<T, U>(U value) => new (value);
    
    public static implicit operator T(OneOf<T, U> oneOf) => oneOf.Value1;
    public static implicit operator U(OneOf<T, U> oneOf) => oneOf.Value2;
    
    public bool Is<TV>()
    {
        return typeof(TV) == typeof(T) == IsValue1;
    }
    
    public override string ToString()
    {
        return IsValue1 ? Value1.ToString() : Value2.ToString();
    }
    
    public override bool Equals(object? obj)
    {
        if (obj is OneOf<T, U> other)
        {
            if (IsValue1 && other.IsValue1)
            {
                return Value1.Equals(other.Value1);
            }
            else if (IsValue2 && other.IsValue2)
            {
                return Value2.Equals(other.Value2);
            }
        }
        
        return false;
    }
    
    public override int GetHashCode()
    {
        return IsValue1 ? Value1.GetHashCode() : Value2.GetHashCode();
    }
    
    public static bool operator ==(OneOf<T, U> left, OneOf<T, U> right)
    {
        return left.Equals(right);
    }
    
    public static bool operator !=(OneOf<T, U> left, OneOf<T, U> right)
    {
        return !(left == right);
    }
    
    public static bool operator ==(OneOf<T, U> left, T right)
    {
        return left.Equals(right);
    }
    
    public static bool operator !=(OneOf<T, U> left, T right)
    {
        return !(left == right);
    }
    
    public static bool operator ==(OneOf<T, U> left, U right)
    {
        return left.Equals(right);
    }
    
    public static bool operator !=(OneOf<T, U> left, U right)
    {
        return !(left == right);
    }
    
    public static bool operator ==(T left, OneOf<T, U> right)
    {
        return right.Equals(left);
    }
    
    public static bool operator !=(T left, OneOf<T, U> right)
    {
        return !(left == right);
    }
    
    public static bool operator ==(U left, OneOf<T, U> right)
    {
        return right.Equals(left);
    }
    
    public static bool operator !=(U left, OneOf<T, U> right)
    {
        return !(left == right);
    }
    
    public void Match(Action<T> value1Action, Action<U> value2Action)
    {
        if (IsValue1)
        {
            value1Action(Value1);
        }
        else
        {
            value2Action(Value2);
        }
    }
    
    public TV Match<TV>(Func<T, TV> value1Action, Func<U, TV> value2Action)
    {
        return IsValue1 ? value1Action(Value1) : value2Action(Value2);
    }
}}

// Domain/Base.cs
namespace CodinGame_Spring_Challenge_2023.Domain{
public class Base : IHaveCellIndex
{
    public int CellIndex { get; set; }
}}

// Domain/Cell.cs
namespace CodinGame_Spring_Challenge_2023.Domain{
public class Cell
{
    public CellType CellType { get; set; }
    public int Resources { get; set; }
    
    public int[] Neighbours { get; set; } = new int[6];

    public int NumAnts => NumMyAnts + NumEnemyAnts;
    public int NumMyAnts { get; set; }
    public int NumEnemyAnts { get; set; }
}}

// Domain/CellType.cs
namespace CodinGame_Spring_Challenge_2023.Domain{
public enum CellType
{
    Empty = 0,
    Eggs = 1,
    Crystal = 2
}}

// Domain/Crystal.cs
namespace CodinGame_Spring_Challenge_2023.Domain{
public class Crystal : IHaveCellIndex
{
    public int CellIndex { get; set; }
}}

// Domain/Egg.cs
namespace CodinGame_Spring_Challenge_2023.Domain{
public class Egg : IHaveCellIndex
{
    public int CellIndex { get; set; }
}}

// Domain/IHaveCellIndex.cs
namespace CodinGame_Spring_Challenge_2023.Domain{
public interface IHaveCellIndex
{
    int CellIndex { get; set; }
}}

// Strategy/StrategyAssessWinConditions.cs
namespace CodinGame_Spring_Challenge_2023.Strategy{
public class StrategyAssessWinConditions
{
    private readonly GameState _gameState;
    private readonly int _startingCrystalResources;
    private int _numFrames;
    
    public int ProjectedTurnsUntilGameEnds { get; private set; }

    public StrategyAssessWinConditions(GameState gameState)
    {
        _gameState = gameState;
        _startingCrystalResources = _gameState.CrystalLocations.Sum(x => _gameState.Cells[x].Resources);
        ProjectedTurnsUntilGameEnds = 10;
        _numFrames = 0;
    }

    public void Update()
    {
        ++_numFrames;

        var remainingCrystalResources = (float)_gameState.CrystalLocations.Sum(x => _gameState.Cells[x].Resources);
        var consumedCrystalResources = _startingCrystalResources - remainingCrystalResources;
        consumedCrystalResources = Math.Max(1f, consumedCrystalResources);

        var consumptionRate = consumedCrystalResources / _numFrames;

        ProjectedTurnsUntilGameEnds =
            (int)Math.Max(2f, Math.Min(10f, 0.5f * remainingCrystalResources / consumptionRate));
    }
}}

// Strategy/StrategyCostBenefitAdaptive.cs
namespace CodinGame_Spring_Challenge_2023.Strategy{
public class StrategyCostBenefitAdaptive
{
    private GameState _gameState;
    private PathFinder _pathFinder;
    private readonly ShortestTree _shortestTree;

    //private List<int> _currentlyVisiting = new();

    public StrategyCostBenefitAdaptive(GameState gameState, PathFinder pathFinder,
        ShortestTree shortestTree)
    {
        _gameState = gameState;
        _pathFinder = pathFinder;
        _shortestTree = shortestTree;
    }

    public static float CalculatePotentialBenefit(List<(int index, float resources)> crystalResources,
        List<(int index, float resources)> eggResources, float myAnts,
        int numLocations, int numFrames, float enemyPotentialConsumeRate)
    {
        if (numFrames == 0)
        {
            return 0;
        }

        var averageAntsPerLocation = myAnts / numLocations;
        if (eggResources.Count == 0)
        {
            return crystalResources.Sum(x => Math.Min(x.resources, numFrames * averageAntsPerLocation));
        }

        var newEggResources = eggResources
            .Select(x => x with { resources = Math.Max(0, x.resources - averageAntsPerLocation) }).ToList();
        var newCrystalResources = crystalResources
            .Select(x => x with { resources = Math.Max(0, x.resources - averageAntsPerLocation) }).ToList();

        var eggsConsumed = newEggResources.Sum(x => Math.Min(x.resources, averageAntsPerLocation));
        var crystalsConsumed = newCrystalResources.Sum(x => Math.Min(x.resources, averageAntsPerLocation));

        var myNewAnts = myAnts + eggsConsumed;

        return 0.2f * enemyPotentialConsumeRate + crystalsConsumed + CalculatePotentialBenefit(newCrystalResources, newEggResources, myNewAnts,
            numLocations, numFrames - 1, enemyPotentialConsumeRate);
    }

    private OneOf<(int cost, float benefit), Invalid> CostBenefit(
        List<int> currentlyVisiting,
        List<int> enemyLocations,
        int potentialLocation,
        bool isEgg,
        int currentNumAnts,
        int enemyNumAnts,
        List<(int index, float resources)> eggsResourcesVisited,
        List<(int index, float resources)> crystalResourcesVisited,
        int lookAhead)
    {
        var enemyDistances = 0;
        if (!enemyLocations.Contains(potentialLocation))
        {
            enemyDistances = _pathFinder.ClosestOrDefault(potentialLocation, enemyLocations).Match(found => found.dist, _ => 5);   
        }

        var enemyPotentialConsumeRate = enemyNumAnts / (enemyLocations.Count + enemyDistances);
        
        var currentBenefit = CalculatePotentialBenefit(crystalResourcesVisited, eggsResourcesVisited, currentNumAnts,
            currentlyVisiting.Count, lookAhead, enemyPotentialConsumeRate);

        return _pathFinder.ClosestOrDefault(potentialLocation, currentlyVisiting)
            .Match<OneOf<(int cost, float benefit), Invalid>>(
                found =>
                {
                    var updatedCrystalResourcesVisited = crystalResourcesVisited.ToList();
                    var updatedEggsResourcesVisited = eggsResourcesVisited.ToList();
                    (isEgg ? ref updatedEggsResourcesVisited : ref updatedCrystalResourcesVisited).Add((found.index,
                        resources: _gameState
                            .Cells[potentialLocation].Resources));

                    var updatedBenefit = CalculatePotentialBenefit(updatedCrystalResourcesVisited,
                        updatedEggsResourcesVisited, currentNumAnts,
                        currentlyVisiting.Count + found.dist, lookAhead, enemyPotentialConsumeRate);

                    if (isEgg)
                    {
                        Console.Error.WriteLine(
                            $"CostBenefit for location {potentialLocation} Eggs: {_gameState.Cells[potentialLocation].Resources} (dist: {found.dist}) = {currentBenefit} -> {updatedBenefit}");
                    }
                    else
                    {
                        Console.Error.WriteLine(
                            $"CostBenefit for location {potentialLocation} Crystals: {_gameState.Cells[potentialLocation].Resources} (dist: {found.dist}) = {currentBenefit} -> {updatedBenefit}");
                    }

                    return (found.dist, updatedBenefit - currentBenefit);
                },
                _ => new Invalid());
    }

    public IEnumerable<int> Update(int projectedTurnsUntilGameEnds)
    {
        Console.Error.WriteLine("Strategy: Projected Turns Until Game Ends: " + projectedTurnsUntilGameEnds);
        var currentlyVisiting = _gameState.MyBaseLocations.ToList();
        while (true)
        {
            Console.Error.WriteLine("Strategy: Currently visiting: " + string.Join(",", currentlyVisiting));
            var potentialLocations = _gameState.CrystalLocations.Select(index => (index, isEgg: false)).ToList();
            var myVisitedEggLocations = currentlyVisiting.Where(x => _gameState.EggLocations.Contains(x))
                .Select(index => (index, resources: (float)_gameState.Cells[index].Resources)).ToList();
            var myVisitedCrystalLocations =
                currentlyVisiting.Where(x => _gameState.CrystalLocations.Contains(x))
                    .Select(index => (index, resources: (float)_gameState.Cells[index].Resources)).ToList();

            if (!myVisitedEggLocations.Any())
            {
                potentialLocations.AddRange(_gameState.EggLocations.Select(index => (index, isEgg: true)));
            }

            var enemyLocations = _gameState.Cells.Where(x => x.NumEnemyAnts > 0).Select((_, index) => index).ToList();

            potentialLocations.RemoveAll(x => currentlyVisiting.Contains(x.index));

            var costBenefits = potentialLocations.Select(x => (
                    x.index,
                    costBenefit: CostBenefit(
                        currentlyVisiting,
                        enemyLocations,
                        x.index,
                        x.isEgg,
                        _gameState.MyAntCount,
                        _gameState.EnemyAntCount,
                        myVisitedEggLocations,
                        myVisitedCrystalLocations,
                        projectedTurnsUntilGameEnds)))
                .Where(x => x.costBenefit.IsValue1)
                .Select(x => (x.index, costBenefit: x.costBenefit.Value1))
                .OrderBy(x => -x.costBenefit.benefit).ToList();

            if (costBenefits.Any())
            {
                foreach (var result in costBenefits)
                {
                    Console.Error.WriteLine(
                        $"Strategy: Cost of going to {result.index} is {result.costBenefit.cost} and benefit is {result.costBenefit.benefit}");
                }

                var first = costBenefits.First();
                if (first.costBenefit.benefit > .5f ||
                    (myVisitedCrystalLocations.Count == 0 && myVisitedEggLocations.Count == 0))
                {
                    //Console.Error.WriteLine($"Strategy: Cost of going to {first.index} is {first.costBenefit.cost} and benefit is {first.costBenefit.benefit}");
                    var locations = _gameState.MyBaseLocations.Concat(myVisitedEggLocations.Select(x => x.index))
                        .Concat(myVisitedCrystalLocations.Select(x => x.index)).Concat(new[] { first.index });
                    currentlyVisiting = ShortestTreeWalker
                        .WalkShortestTree(_gameState, _pathFinder, _shortestTree.GetShortestTree(locations)).ToList();
                    continue;
                }
            }

            break;
        }

        return currentlyVisiting;

        //WFC of all possible states? We consider if we add each one and the cost/benefit.
        //AStar search maybe or all possible states and then we pick the best one?
        //Each addition takes away from the rest, so we look to find optimal


        /*
        var totalAnts = _gameState.MyAntCount;

        var locationsIncludedInStrategy = new HashSet<int>();
        var projectedEggCollection = 0;
        var projectedCrystalCollection = 0;

        var orderedLocations = _pathFinder.OrderedPairs(
            _gameState,
            _gameState.MyBaseLocations,
            (_gameState.EggLocations, CellType.Eggs),
            (_gameState.CrystalLocations, CellType.Crystal));

        foreach (var (fromIndex, toIndex, dist, cellType) in orderedLocations)
        {
            switch (cellType)
            {
                case CellType.Crystal:
                {
                    
                    break;
                }

                case CellType.Eggs:
                {
                    
                    
                    break;
                }
            }
        }
        return _gameState.MyBaseLocations;
        */
    }
}}

// PathFinding/MapInfo.cs
namespace CodinGame_Spring_Challenge_2023.PathFinding{
public class MapInfo
{
    private GameState _gameState;
    private PathFinder _pathFinder;

    public List<CellMapInfoDynamic> CellMapInfoDynamic { get; } = new();
    public List<CellMapInfoStatic> CellMapInfoStatic { get; } = new();

    public MapInfo(GameState gameState, PathFinder pathFinder)
    {
        _gameState = gameState;
        _pathFinder = pathFinder;
    }
    
    public void UpdateStatic()
    {
        if (CellMapInfoStatic.Count > 0) return;
        
        for (var i = 0; i < _gameState.NumberOfCells; ++i)
        {
            var cellMapInfoStatic = new CellMapInfoStatic
            {
                MyClosestBase = -1,
                EnemyClosestBase = -1
            };

            var closestDistances = _pathFinder.ClosestDistances(i, _gameState.MyBaseLocations);
            if (closestDistances.Any())
            {
                cellMapInfoStatic.MyClosestBase = closestDistances.First().index;
            }

            closestDistances = _pathFinder.ClosestDistances(i, _gameState.EnemyBaseLocations);
            if (closestDistances.Any())
            {
                cellMapInfoStatic.EnemyClosestBase = closestDistances.First().index;
            }
            
            CellMapInfoStatic.Add(cellMapInfoStatic);
            CellMapInfoDynamic.Add(new CellMapInfoDynamic());
        }
    }
    
    public void UpdateDynamic()
    {
        for (var i = 0; i < _gameState.NumberOfCells; ++i)
        {
            CellMapInfoDynamic[i].Resources = _gameState.Cells[i].Resources;
        }
    }
    
    public (CellMapInfoStatic staticInfo, CellMapInfoDynamic dynamicInfo) GetCellInfo(int cellIndex)
    {
        return (CellMapInfoStatic[cellIndex], CellMapInfoDynamic[cellIndex]);
    }
}

public record CellMapInfoStatic
{
    public int MyClosestBase;
    public int EnemyClosestBase;
}

public record CellMapInfoDynamic
{
    public int Resources;
}}

// PathFinding/PathFinder.cs
namespace CodinGame_Spring_Challenge_2023.PathFinding{
public class PathFinder
{
    private readonly int _numCells;

    private readonly List<Dictionary<int, (int dir, int dist)>> _cellPathMap =
        new List<Dictionary<int, (int dir, int dist)>>();

    private bool _fullyExpanded;

    private Action _onPathExpansionComplete;

    public PathFinder(GameState gameState)
    {
        _numCells = gameState.NumberOfCells;
        _onPathExpansionComplete = () => { };

        BuildPathInfo(gameState);
    }

    public PathFinder(List<Dictionary<int, (int dir, int dist)>> cellPathMap, int numCells)
    {
        _numCells = numCells;
        _cellPathMap = cellPathMap;
        _onPathExpansionComplete = () => { };
    }

    public void OnPathExpansionComplete(Action action)
    {
        _onPathExpansionComplete = action;
    }

    public bool ExpandPathKnowledge()
    {
        if (_fullyExpanded) return true;

        var newPathsFound = new List<(int from, int fromDir, int to, int toDir, int dist)>();

        for (var i = 0; i < _numCells; ++i)
        {
            var pathsForCell = _cellPathMap[i];

            foreach (var knownCellIndex in pathsForCell.Keys)
            {
                var pathToKnownCell = pathsForCell[knownCellIndex];
                var pathsForKnownCell = _cellPathMap[knownCellIndex];
                foreach (var otherCellIndex in pathsForKnownCell.Keys)
                {
                    if (i == otherCellIndex) continue;

                    var possibleDistViaKnownCell = pathToKnownCell.dist + pathsForKnownCell[otherCellIndex].dist;

                    if (pathsForCell.TryGetValue(otherCellIndex, out var myCurrentBestPathToOtherCell))
                    {
                        if (myCurrentBestPathToOtherCell.dist <= possibleDistViaKnownCell)
                        {
                            continue;
                        }
                    }

                    //We are new here or simply have a better path!
                    var pathsForOtherCell = _cellPathMap[otherCellIndex];
                    newPathsFound.Add((i, pathToKnownCell.dir, otherCellIndex, pathsForOtherCell[knownCellIndex].dir,
                        possibleDistViaKnownCell));
                }
            }
        }

        if (newPathsFound.Count == 0)
        {
            _fullyExpanded = true;
            _onPathExpansionComplete();
            return true;
        }

        foreach (var newPath in newPathsFound)
        {
            _cellPathMap[newPath.from][newPath.to] = (newPath.fromDir, newPath.dist);
            _cellPathMap[newPath.to][newPath.from] = (newPath.toDir, newPath.dist);
        }

        return false;
    }


    private void BuildPathInfo(GameState gameState)
    {
        for (var i = 0; i < gameState.NumberOfCells; ++i)
        {
            var pathsForCell = new Dictionary<int, (int dir, int dist)>();
            _cellPathMap.Add(pathsForCell);

            var cell = gameState.Cells[i];
            for (var dir = 0; dir < 6; ++dir)
            {
                var neighbourIndex = cell.Neighbours[dir];
                if (neighbourIndex == -1) continue;

                pathsForCell.Add(neighbourIndex, (dir, 1));
            }
        }
    }
    /*
for (var i = 0; i < _gameState.NumberOfCells; ++i)
    {
        var cell = _gameState.Cells[i];
        var pathsForCell = _cellPathMap[i];

        foreach (var pathToIndex in pathsForCell.Keys)
        {
            var knownCell = _gameState.Cells[pathToIndex];
            var pathsForKnownCell = _cellPathMap[pathToIndex];
            foreach (var otherPathToIndex in pathsForCell.Keys)
            {
                if (pathToIndex == otherPathToIndex) continue;

                if (!pathsForKnownCell.ContainsKey(otherPathToIndex))
                {
                    pathsForKnownCell[otherPathToIndex] = pathsForCell[pathToIndex].
                }   
            }
        }
    }
}
*/

    public IOrderedEnumerable<(int index, int dist)> ClosestDistances(int fromIndex, IEnumerable<int> toIndexList) =>
        toIndexList.Select(index => (index, dist: Distance(fromIndex, index))).Where((_, dist) => dist > -1)
            .OrderBy(x => x.dist);

    public OneOf<(int index, int dist), NotFound> ClosestOrDefault(int fromIndex, IEnumerable<int> toIndexList)
    {
        var closestDistances = ClosestDistances(fromIndex, toIndexList);
        if (closestDistances.Any())
        {
            return closestDistances.First();
        }

        return new NotFound();
    }

    public int Distance(int fromIndex, int toIndex)
    {
        if (_cellPathMap[fromIndex].TryGetValue(toIndex, out var path))
        {
            return path.dist;
        }

        return -1;
    }

    public IEnumerable<int> PathTo(GameState gameState, int fromIndex, int toIndex)
    {
        if (!_cellPathMap[fromIndex].ContainsKey(toIndex))
        {
            return Enumerable.Empty<int>();
        }

        var path = new List<int>();
        var currentCellIndex = fromIndex;
        while (currentCellIndex != toIndex)
        {
            path.Add(currentCellIndex);
            var nextCellDir = _cellPathMap[currentCellIndex][toIndex].dir;
            currentCellIndex = gameState.Cells[currentCellIndex].Neighbours[nextCellDir];
        }

        path.Add(toIndex);
        return path;
    }

    public IEnumerable<int> ClosestNOf(GameState gameState, int num, params IEnumerable<int>[] indexLists)
    {
        var closest = new List<int>();
        var closestDistances = new List<int>();
        foreach (var indexList in indexLists)
        {
            foreach (var index in indexList)
            {
                var dist = Distance(gameState.MyBases[0].CellIndex, index);
                if (dist == -1) continue;

                var indexToInsertAt = closestDistances.FindIndex(d => d > dist);
                if (indexToInsertAt == -1)
                {
                    indexToInsertAt = closest.Count;
                }

                closest.Insert(indexToInsertAt, index);
                closestDistances.Insert(indexToInsertAt, dist);
            }
        }

        return closest.Take(num);
    }

    public IOrderedEnumerable<(int fromIndex, int toIndex, int dist, CellType cellType)> OrderedPairs(GameState gameState,
        IEnumerable<int> fromList, params (IEnumerable<int>, CellType)[] indexLists)
    {
        var orderedPairs = (
            from fromIndex in fromList
            from list in indexLists
            from toIndex in list.Item1
            select (fromIndex, toIndex, dist: Distance(fromIndex, toIndex), cellType: list.Item2)
        ).ToList();

        return orderedPairs.OrderBy(x => x.dist);
    }

    public string DebugDistances(GameState gameState)
    {
        var output = "Distances from my base: ";
        foreach (var myBase in gameState.MyBases)
        {
            var crystalDistances = ClosestDistances(myBase.CellIndex, gameState.CrystalLocations);
            foreach (var crystal in crystalDistances)
            {
                output += $"({crystal.index}, {crystal.dist}) ";
            }
        }

        output += " Distances from enemy base: ";
        foreach (var enemyBase in gameState.EnemyBases)
        {
            var crystalDistances = ClosestDistances(enemyBase.CellIndex, gameState.CrystalLocations);
            foreach (var crystal in crystalDistances)
            {
                output += $"({crystal.index}, {crystal.dist}) ";
            }
        }

        return output;
    }

    public string DebugPaths(GameState gameState)
    {
        var output = "Paths from my base: ";
        foreach (var myBase in gameState.MyBases)
        {
            foreach (var crystal in gameState.CrystalLocations)
            {
                var path = PathTo(gameState, myBase.CellIndex, crystal);
                output += $"(Base({myBase.CellIndex}) -> Crystal({crystal}) : ";
                foreach (var step in path)
                {
                    output += step + " ";
                }
            }
        }

        output += " Paths from enemy base: ";
        foreach (var enemyBase in gameState.EnemyBases)
        {
            foreach (var crystal in gameState.CrystalLocations)
            {
                var path = PathTo(gameState, enemyBase.CellIndex, crystal);
                output += $"(Base({enemyBase.CellIndex}) -> Crystal({crystal}) : ";
                foreach (var step in path)
                {
                    output += step + " ";
                }
            }
        }

        return output;
    }
}}

// PathFinding/ShortestTree.cs
namespace CodinGame_Spring_Challenge_2023.PathFinding
{
    public class ShortestTree
    {
        private PathFinder _pathFinder;
        
        public ShortestTree(PathFinder pathFinder)
        {
            _pathFinder = pathFinder;
        }
        
        public IEnumerable<(int fromIndex, int toIndex)> GetShortestTree(IEnumerable<int> includeLocations)
        {
            var shortestTree = new List<(int fromIndex, int toIndex)>();
            
            var visited = new HashSet<int>();
            var unvisited = new HashSet<int>();
            foreach (var index in includeLocations)
            {
                unvisited.Add(index);
            }
            
            var currentCellIndex = unvisited.First();
            visited.Add(currentCellIndex);
            unvisited.Remove(currentCellIndex);
            
            while (unvisited.Count > 0)
            {
                var shortestPath = (fromIndex: -1, toIndex: -1, dist: int.MaxValue);
                foreach (var visitedCellIndex in visited)
                {
                    foreach (var unvisitedCellIndex in unvisited)
                    {
                        var dist = _pathFinder.Distance(unvisitedCellIndex, visitedCellIndex);
                        if (dist < 0) continue;
                        
                        if (dist < shortestPath.dist)
                        {
                            shortestPath = (visitedCellIndex, unvisitedCellIndex, dist);
                        }
                    }
                }
                
                shortestTree.Add((shortestPath.fromIndex, shortestPath.toIndex));
                
                visited.Add(shortestPath.toIndex);
                unvisited.Remove(shortestPath.toIndex);
            }
            
            return shortestTree;
        }
    }
}

// PathFinding/ShortestTreeWalker.cs
namespace CodinGame_Spring_Challenge_2023.PathFinding
{
    public static class ShortestTreeWalker
    {
        public static IEnumerable<int> WalkShortestTree(GameState gameState, PathFinder pathFinder,
            IEnumerable<(int fromIndex, int toIndex)> tree) => tree
            .SelectMany(x => pathFinder.PathTo(gameState, x.fromIndex, x.toIndex)).Distinct();
    }
}
