// File generated by dotnet-combine at 2023-05-28__00_54_39

using System;
using System.Collections.Generic;
using System.Linq;




public class Base : IHaveCellIndex
{
    public int CellIndex { get; set; }
}


public class Cell
{
    public CellType CellType { get; set; }
    public int Resources { get; set; }
    
    public int[] Neighbours { get; set; } = new int[6];

    public int NumAnts => NumMyAnts + NumEnemyAnts;
    public int NumMyAnts { get; set; }
    public int NumEnemyAnts { get; set; }
}

public enum CellType
{
    Empty = 0,
    Eggs = 1,
    Crystal = 2
}


public class Crystal : IHaveCellIndex
{
    public int CellIndex { get; set; }
}


public class Egg : IHaveCellIndex
{
    public int CellIndex { get; set; }
}


public class GameActions
{
    private const bool ShowDebug = true;
    
    private List<string> Actions { get; set; } = new List<string>();

    public GameActions()
    {
    }

    public void FlushMoves()
    {
        if (Actions.Count == 0)
        {
            Wait();
        }
        
        Console.WriteLine(string.Join(";", Actions));
        
        Actions.Clear();
    }
    
    // WAIT | LINE <sourceIdx> <targetIdx> <strength> | BEACON <cellIdx> <strength> | MESSAGE <text>
    public void Wait()
    {
        Actions.Add("WAIT");
    }
        
    public void Line(int sourceIdx, int targetIdx, int strength, string message = null)
    {
        DebugMessage(message);
        Actions.Add($"LINE {sourceIdx} {targetIdx} {strength}");
    }
        
    public void Beacon(int cellIdx, int strength, string message = null)
    {
        DebugMessage(message);
        Actions.Add($"BEACON {cellIdx} {strength}");
    }
        
    public void Message(string text)
    {
        Actions.Add($"MESSAGE {text}");
    }

    public void DebugMessage(string message)
    {
        if (!ShowDebug || message == null) return;
        
        Message(message);
    }
}


public class GameState
{
    public int NumberOfCells { get; set; }
    public int NumberOfBasesPerPlayer { get; set; }
    
    public List<Base> MyBases { get; set; } = new List<Base>();
    public List<Base> EnemyBases { get; set; } = new List<Base>();
    public List<Cell> Cells { get; set; } = new List<Cell>();
    public List<Crystal> Crystals { get; set; } = new List<Crystal>();
    public List<Egg> Eggs { get; set; } = new List<Egg>();
    
    public List<int> MyBaseLocations { get; set; } = new List<int>();
    public List<int> EnemyBaseLocations { get; set; } = new List<int>();
    public List<int> CellLocations { get; set; } = new List<int>();
    public List<int> CrystalLocations { get; set; } = new List<int>();
    public List<int> EggLocations { get; set; } = new List<int>();
}


public class GameStateReader
{
    private void ReadNumberOfCells(GameState gameState)
    {
        // amount of hexagonal cells in this map
        gameState.NumberOfCells = int.Parse(Console.ReadLine());
    }

    private void ReadInitialCellState(GameState gameState)
    {
        for (var i = 0; i < gameState.NumberOfCells; i++)
        {
            var inputs = Console.ReadLine().Split(' ');
            var type = (CellType) int.Parse(inputs[0]); // 0 for empty, 1 for eggs, 2 for crystal
            var initialResources = int.Parse(inputs[1]); // the initial amount of eggs/crystals on this cell
            var neigh0 = int.Parse(inputs[2]); // the index of the neighbouring cell for each direction
            var neigh1 = int.Parse(inputs[3]);
            var neigh2 = int.Parse(inputs[4]);
            var neigh3 = int.Parse(inputs[5]);
            var neigh4 = int.Parse(inputs[6]);
            var neigh5 = int.Parse(inputs[7]);

            gameState.Cells.Add(new Cell
            {
                CellType = type,
                Resources = initialResources,
                Neighbours = new[] { neigh0, neigh1, neigh2, neigh3, neigh4, neigh5 }
            });
            
            if (type == CellType.Crystal)
            {
                gameState.Crystals.Add(new Crystal { CellIndex = i });
                gameState.CrystalLocations.Add(i);
            }
            
            if (type == CellType.Eggs)
            {
                gameState.Eggs.Add(new Egg { CellIndex = i });
                gameState.EggLocations.Add(i);
            }
        }
    }

    private void ReadNumberOfBases(GameState gameState)
    {
        gameState.NumberOfBasesPerPlayer = int.Parse(Console.ReadLine());
    }

    private void ReadBases(GameState gameState, ICollection<Base> bases, ICollection<int> baseLocations)
    {
        var inputs = Console.ReadLine().Split(' ');
        for (var i = 0; i < gameState.NumberOfBasesPerPlayer; i++)
        {
            var baseIndex = int.Parse(inputs[i]);
            bases.Add(new Base { CellIndex = baseIndex });
            baseLocations.Add(baseIndex);
        }
    }

    public GameState ReadInitialState()
    {
        var gameState = new GameState();
        ReadNumberOfCells(gameState);
        ReadInitialCellState(gameState);
        ReadNumberOfBases(gameState);
        ReadBases(gameState, gameState.MyBases, gameState.MyBaseLocations);
        ReadBases(gameState, gameState.EnemyBases, gameState.EnemyBaseLocations);

        return gameState;
    }

    public void ReadStateUpdate(GameState gameState)
    {
        for (var i = 0; i < gameState.NumberOfCells; i++)
        {
            var inputs = Console.ReadLine().Split(' ');
            var resources = int.Parse(inputs[0]); // the current amount of eggs/crystals on this cell
            var myAnts = int.Parse(inputs[1]); // the amount of your ants on this cell
            var oppAnts = int.Parse(inputs[2]); // the amount of opponent ants on this cell
            
            gameState.Cells[i].Resources = resources;
            gameState.Cells[i].NumMyAnts = myAnts;
            gameState.Cells[i].NumEnemyAnts = oppAnts;
            
            if (resources == 0 && gameState.CrystalLocations.Contains(i))
            {
                gameState.CrystalLocations.Remove(i);
                gameState.Crystals.RemoveAll(x => x.CellIndex == i);
            }
            
            if (resources == 0 && gameState.EggLocations.Contains(i))
            {
                gameState.EggLocations.Remove(i);
                gameState.Eggs.RemoveAll(x => x.CellIndex == i);
            }
        }
    }
}

public interface IHaveCellIndex
{
    int CellIndex { get; set; }
}


public class Path
{
    public List<int> Steps { get; set; }
    public int Distance => Steps.Count + 1;
}


public class PathFinder
{
    private GameState _gameState;

    private List<Dictionary<int, (int dir, int dist)>> _cellPathMap = new List<Dictionary<int, (int dir, int dist)>>();

    private bool fullyExpanded = false;

    public PathFinder(GameState gameState)
    {
        _gameState = gameState;

        BuildPathInfo();
    }

    public void ExpandPathKnowledge()
    {
        if (fullyExpanded) return;

        var newPathsFound = new List<(int from, int fromDir, int to, int toDir, int dist)>();

        for (var i = 0; i < _gameState.NumberOfCells; ++i)
        {
            var pathsForCell = _cellPathMap[i];

            foreach (var knownCellIndex in pathsForCell.Keys)
            {
                var pathToKnownCell = pathsForCell[knownCellIndex];
                var pathsForKnownCell = _cellPathMap[knownCellIndex];
                foreach (var otherCellIndex in pathsForKnownCell.Keys)
                {
                    if (i == otherCellIndex) continue;

                    var possibleDistViaKnownCell = pathToKnownCell.dist + pathsForKnownCell[otherCellIndex].dist;

                    if (pathsForCell.TryGetValue(otherCellIndex, out var myCurrentBestPathToOtherCell))
                    {
                        if (myCurrentBestPathToOtherCell.dist < possibleDistViaKnownCell)
                        {
                            continue;
                        }
                    }

                    //We are new here or simply have a better path!
                    var pathsForOtherCell = _cellPathMap[otherCellIndex];
                    newPathsFound.Add((i, pathToKnownCell.dir, otherCellIndex, pathsForOtherCell[knownCellIndex].dir,
                        possibleDistViaKnownCell));
                }
            }
        }

        if (newPathsFound.Count == 0)
        {
            fullyExpanded = true;
            return;
        }

        foreach (var newPath in newPathsFound)
        {
            _cellPathMap[newPath.from][newPath.to] = (newPath.fromDir, newPath.dist);
            _cellPathMap[newPath.to][newPath.from] = (newPath.toDir, newPath.dist);
        }
    }


    private void BuildPathInfo()
    {
        for (var i = 0; i < _gameState.NumberOfCells; ++i)
        {
            var pathsForCell = new Dictionary<int, (int dir, int dist)>();
            _cellPathMap.Add(pathsForCell);

            var cell = _gameState.Cells[i];
            for (var dir = 0; dir < 6; ++dir)
            {
                var neighbourIndex = cell.Neighbours[dir];
                if (neighbourIndex == -1) continue;

                pathsForCell.Add(neighbourIndex, (dir, 1));
            }
        }
    }
    /*
    for (var i = 0; i < _gameState.NumberOfCells; ++i)
        {
            var cell = _gameState.Cells[i];
            var pathsForCell = _cellPathMap[i];

            foreach (var pathToIndex in pathsForCell.Keys)
            {
                var knownCell = _gameState.Cells[pathToIndex];
                var pathsForKnownCell = _cellPathMap[pathToIndex];
                foreach (var otherPathToIndex in pathsForCell.Keys)
                {
                    if (pathToIndex == otherPathToIndex) continue;

                    if (!pathsForKnownCell.ContainsKey(otherPathToIndex))
                    {
                        pathsForKnownCell[otherPathToIndex] = pathsForCell[pathToIndex].
                    }   
                }
            }
        }
    }
    */

    public IOrderedEnumerable<(int index, int dist)> ClosestDistances(int fromIndex, IEnumerable<int> toIndexList) =>
        toIndexList.Select(index => (index: index, dist: Distance(fromIndex, index))).Where((_, dist) => dist > -1)
            .OrderBy(x => x.dist);

    public (int index, int dist) ClosestOrDefault(int fromIndex, IEnumerable<int> toIndexList)
    {
        var closestDistances = ClosestDistances(fromIndex, toIndexList);
        if (closestDistances.Any())
        {
            return closestDistances.First();
        }
        
        return (-1, -1);
    }
    
    public int Distance(int fromIndex, int toIndex)
    {
        if (_cellPathMap[fromIndex].TryGetValue(toIndex, out var path))
        {
            return path.dist;
        }

        return -1;
    }
    
    public IEnumerable<int> PathTo(int fromIndex, int toIndex)
    {
        if (!_cellPathMap[fromIndex].ContainsKey(toIndex))
        {
            return Enumerable.Empty<int>();
        }
        
        var path = new List<int>();
        var currentCellIndex = fromIndex;
        while (currentCellIndex != toIndex)
        {
            path.Add(currentCellIndex);
            var nextCellDir = _cellPathMap[currentCellIndex][toIndex].dir;
            currentCellIndex = _gameState.Cells[currentCellIndex].Neighbours[nextCellDir];
        }

        path.Add(toIndex);
        return path;
    }

    public string DebugDistances(GameState gameState)
    {
        var output = "Distances from my base: ";
        foreach (var myBase in gameState.MyBases)
        {
            var crystalDistances = ClosestDistances(myBase.CellIndex, gameState.CrystalLocations);
            foreach (var crystal in crystalDistances)
            {
                output += $"({crystal.index}, {crystal.dist}) ";
            }
        }
        
        output += " Distances from enemy base: ";
        foreach (var enemyBase in gameState.EnemyBases)
        {
            var crystalDistances = ClosestDistances(enemyBase.CellIndex, gameState.CrystalLocations);
            foreach (var crystal in crystalDistances)
            {
                output += $"({crystal.index}, {crystal.dist}) ";
            }
        }

        return output;
    }

    public string DebugPaths(GameState gameState)
    {
        var output = "Paths from my base: ";
        foreach (var myBase in gameState.MyBases)
        {
            foreach (var crystal in gameState.CrystalLocations)
            {
                var path = PathTo(myBase.CellIndex, crystal);
                output += $"(Base({myBase.CellIndex}) -> Crystal({crystal}) : ";
                foreach (var step in path)
                {
                    output += step + " ";
                }
            }
        }
        
        output += " Paths from enemy base: ";
        foreach (var enemyBase in gameState.EnemyBases)
        {
            foreach (var crystal in gameState.CrystalLocations)
            {
                var path = PathTo(enemyBase.CellIndex, crystal);
                output += $"(Base({enemyBase.CellIndex}) -> Crystal({crystal}) : ";
                foreach (var step in path)
                {
                    output += step + " ";
                }
            }
        }

        return output;
    }
}


public static class Player
{
    static void Main(string[] args)
    {
        var gameActions = new GameActions();
        var gameStateReader = new GameStateReader();
        var gameState = gameStateReader.ReadInitialState();
        var pathFinder = new PathFinder(gameState);

        var strengthToUseForMyCrystals = 2;
        var strengthToUseForEnemyCrystals = 1;

        var myClosestCost = 0.3f;
        var enemyClosestCost = 0.7f;

        var crystalInitialCost = 10f;
        var eggInitialCost = 1f;
        var crystalAdjustmentEachFrame = -0.5f;

        var crystalCost = crystalInitialCost;
        var eggCost = eggInitialCost;

        // game looping
        while (true)
        {
            gameStateReader.ReadStateUpdate(gameState);
            pathFinder.ExpandPathKnowledge();
            Console.Error.WriteLine(pathFinder.DebugPaths(gameState));

            if (gameState.EggLocations.Count == 0)
            {
                crystalCost = 1f;
            }

            //TODO: Have some consideration over the overall game state, i.e. lots of crystals and lots of ants, or few ants and lots of eggs, etc.

            var locationsOfInterest = gameState.CrystalLocations
                .Select(cellIndex => (cellIndex, cellType: CellType.Crystal))
                .Concat(gameState.EggLocations.Select(cellIndex => (cellIndex, cellType: CellType.Eggs)));

            var myClosestLocationsOfInterest = locationsOfInterest
                .Select(location => (
                    location.cellIndex,
                    location.cellType,
                    preferenceCostFactor: location.cellType == CellType.Crystal ? crystalCost : eggCost,
                    distForMe: pathFinder.ClosestOrDefault(location.cellIndex, gameState.MyBaseLocations),
                    distForEnemy: pathFinder.ClosestOrDefault(location.cellIndex, gameState.EnemyBaseLocations)))
                .Where(x => x.distForMe.index != -1)
                .Select(
                    x => (
                        x.cellIndex,
                        x.cellType,
                        baseIndex: x.distForMe.index,
                        closerToEnemy: x.distForEnemy.index > -1 && x.distForEnemy.dist < x.distForMe.dist,
                        cost: x.preferenceCostFactor * (x.distForMe.dist * myClosestCost +
                                                        (x.distForEnemy.index > -1 ? 100 : x.distForEnemy.dist) *
                                                        enemyClosestCost)))
                .OrderBy(x => -x.cost);

            var myLocationCount = 0;
            var enemyLocationCount = 0;
            var crystalsCount = 0;
            var eggsCount = 0;

            foreach (var location in myClosestLocationsOfInterest)
            {
                if (location.closerToEnemy)
                {
                    //Don't go to too many enemy locations
                    if (enemyLocationCount == 0)
                    {
                        gameActions.Line(location.baseIndex, location.cellIndex, strengthToUseForEnemyCrystals);
                        ++enemyLocationCount;   
                    }
                }
                else
                {
                    gameActions.Line(location.baseIndex, location.cellIndex, strengthToUseForMyCrystals);
                    ++myLocationCount;
                }

                if (location.cellType == CellType.Crystal)
                {
                    ++crystalsCount;
                }
                else
                {
                    ++eggsCount;
                }

                if (myLocationCount > 0 && enemyLocationCount > 0 && crystalsCount > 0 && eggsCount > 0)
                {
                    break;
                }
            }
            
            gameActions.Message($"My Locations: {myLocationCount}, Enemy Locations: {enemyLocationCount}, Crystals: {crystalsCount}, Eggs: {eggsCount}");

            // Write an action us Console.WriteLine()
            // To debug: Console.Error.WriteLine("Debug messages...");
            gameActions.FlushMoves();

            crystalCost = Math.Max(1f, crystalCost + crystalAdjustmentEachFrame);
        }
    }
}
