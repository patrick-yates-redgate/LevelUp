// File generated by dotnet-combine at 2023-05-29__12_08_00

using CodinGame_Spring_Challenge_2023.Core;
using CodinGame_Spring_Challenge_2023.Domain;
using CodinGame_Spring_Challenge_2023.PathFinding;
using CodinGame_Spring_Challenge_2023.Strategy;
using CodinGame_Spring_Challenge_2023.Utils;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;



// Player.cs
namespace CodinGame_Spring_Challenge_2023{
public static class Player
{
    static void Main(string[] args)
    {
        var gameActions = new GameActions();
        var gameState = GameStateReader.ReadInitialState();
        var pathFinder = new PathFinder(gameState);
        var shortestTree = new ShortestTree(pathFinder);
        var mapInfo = new MapInfo(gameState, pathFinder);
        var strategyCostBenefitAdaptive = new StrategyCostBenefitAdaptive(gameState, pathFinder, mapInfo, shortestTree);
        
        pathFinder.OnPathExpansionComplete(() =>
        {
            GameStateReader.DetermineOwnership(gameState, pathFinder);
            mapInfo.UpdateStatic();
        });

        var maxLoops = 20;
        while (!pathFinder.ExpandPathKnowledge() && maxLoops-- > 0)
        {
        }

        if (maxLoops == 0)
        {
            Console.Error.WriteLine("Could not complete path map, will update each frame but may not be optimal");
        }

        List<int> currentlyVisiting = new List<int>();

        // game looping
        while (true)
        {
            GameStateReader.ReadStateUpdate(gameState);
            pathFinder.ExpandPathKnowledge();

            foreach (var index in strategyCostBenefitAdaptive.Update())
            {
                gameActions.Beacon(index, 1);
            }
            
            /*
            currentlyVisiting.RemoveAll(index => gameState.Cells[index].Resources == 0);
            
            if (currentlyVisiting.Count == 0)
            {
                currentlyVisiting = gameState.MyBaseLocations.ToList();
            }

            //TODO, build existing tree to build on
            var allpoints =
                ShortestTreeWalker.WalkShortestTree(gameState, pathFinder, shortestTree.GetShortestTree(locations));
            
            
            var eggsCloserThan3FromBase = gameState.EggLocations.Select(x => gameState.)
                
                
            var shortestTreeUsingHighestValueMyCrystalAndClosestEggLessThan3FromBase =
                new int[] { gameState.MyCrystalLocations.Max(x => gameState.Cells[x].Resources) }



            var eggs = pathFinder.ClosestNOf(gameState, 1, gameState.MyEggLocations, gameState.ContestedEggLocations)
                .ToList();
            var crystals = pathFinder.ClosestNOf(gameState, 1, gameState.ContestedCrystalLocations,
                gameState.EnemyCrystalLocations);

            var locations = new[]
            {
                gameState.MyBaseLocations,
                gameState.MyCrystalLocations,
                crystals,
                eggs
            }.SelectMany(x => x).ToList();

            Console.Error.WriteLine(string.Join(",", locations.Select(x => x.ToString())));
*/

            // MUST TRIM THE NODES BEFORE WE PASS IN HERE, NOT AFTER

            /*
        shortestTree.GetShortestTree(locations)
            .ToList()
            .ForEach(x =>
            {
                var dist = pathFinder.Distance(x.fromIndex, x.toIndex);
                var isEgg = eggs.Contains(x.toIndex) || eggs.Contains(x.fromIndex);
                if (isEgg)
                {
                    var strength = 3 - dist;
                    if (strength > 0)
                    {
                        gameActions.Line(x.fromIndex, x.toIndex, strength * 10);
                    }

                    return;
                }

                var isMyCrystal = gameState.MyCrystalLocations.Contains(x.toIndex) ||
                                  gameState.MyCrystalLocations.Contains(x.fromIndex);
                gameActions.Line(x.fromIndex, x.toIndex, isMyCrystal ? 6 : 2);
            });
            */

            gameActions.FlushMoves();
        }
    }
}}

// Core/GameActions.cs
namespace CodinGame_Spring_Challenge_2023.Core{
public class GameActions
{
    private const bool ShowDebug = true;
    
    private List<string> Actions { get; set; } = new List<string>();

    public GameActions()
    {
    }

    public void FlushMoves()
    {
        if (Actions.Count == 0)
        {
            Wait();
        }
        
        Console.WriteLine(string.Join(";", Actions));
        
        Actions.Clear();
    }
    
    // WAIT | LINE <sourceIdx> <targetIdx> <strength> | BEACON <cellIdx> <strength> | MESSAGE <text>
    public void Wait()
    {
        Actions.Add("WAIT");
    }
        
    public void Line(int sourceIdx, int targetIdx, int strength, string message = null)
    {
        DebugMessage(message);
        Actions.Add($"LINE {sourceIdx} {targetIdx} {strength}");
    }
        
    public void Beacon(int cellIdx, int strength, string message = null)
    {
        DebugMessage(message);
        Actions.Add($"BEACON {cellIdx} {strength}");
    }
        
    public void Message(string text)
    {
        Actions.Add($"MESSAGE {text}");
    }

    public void DebugMessage(string message)
    {
        if (!ShowDebug || message == null) return;
        
        Message(message);
    }
}}

// Core/GameState.cs
namespace CodinGame_Spring_Challenge_2023.Core{
public class GameState
{
    public int NumberOfCells { get; set; }
    public int NumberOfBasesPerPlayer { get; set; }
    
    public int MyAntCount { get; set; }
    public int EnemyAntCount { get; set; }
    
    public int MyCrystalCount { get; set; }
    public int EnemyCrystalCount { get; set; }
    
    public List<Base> MyBases { get; set; } = new ();
    public List<Base> EnemyBases { get; set; } = new ();
    public List<Cell> Cells { get; set; } = new ();
    public List<Crystal> Crystals { get; set; } = new ();
    public List<Egg> Eggs { get; set; } = new ();
    
    public List<int> MyBaseLocations { get; set; } = new ();
    public List<int> EnemyBaseLocations { get; set; } = new ();
    public List<int> CrystalLocations { get; set; } = new ();
    public List<int> EggLocations { get; set; } = new ();
    public List<int> MyCrystalLocations { get; set; } = new ();
    public List<int> EnemyCrystalLocations { get; set; } = new ();
    public List<int> MyEggLocations { get; set; } = new ();
    public List<int> EnemyEggLocations { get; set; } = new ();
    public List<int> ContestedCrystalLocations { get; set; } = new ();
    public List<int> ContestedEggLocations { get; set; } = new ();

    public Dictionary<int, int> MyAntLookup { get; set; } = new ();

    public Dictionary<int, int> EnemyAntLookup { get; set; } = new ();
}}

// Core/GameStateReader.cs
namespace CodinGame_Spring_Challenge_2023.Core{
public static class GameStateReader
{
    private static void ReadNumberOfCells(GameState gameState)
    {
        // amount of hexagonal cells in this map
        gameState.NumberOfCells = int.Parse(Console.ReadLine());
    }

    private static void ReadInitialCellState(GameState gameState)
    {
        for (var i = 0; i < gameState.NumberOfCells; i++)
        {
            var inputs = Console.ReadLine().Split(' ');
            var type = (CellType)int.Parse(inputs[0]); // 0 for empty, 1 for eggs, 2 for crystal
            var initialResources = int.Parse(inputs[1]); // the initial amount of eggs/crystals on this cell
            var neigh0 = int.Parse(inputs[2]); // the index of the neighbouring cell for each direction
            var neigh1 = int.Parse(inputs[3]);
            var neigh2 = int.Parse(inputs[4]);
            var neigh3 = int.Parse(inputs[5]);
            var neigh4 = int.Parse(inputs[6]);
            var neigh5 = int.Parse(inputs[7]);

            gameState.Cells.Add(new Cell
            {
                CellType = type,
                Resources = initialResources,
                Neighbours = new[] { neigh0, neigh1, neigh2, neigh3, neigh4, neigh5 }
            });

            if (type == CellType.Crystal)
            {
                gameState.Crystals.Add(new Crystal { CellIndex = i });
                gameState.CrystalLocations.Add(i);
            }

            if (type == CellType.Eggs)
            {
                gameState.Eggs.Add(new Egg { CellIndex = i });
                gameState.EggLocations.Add(i);
            }
        }
    }

    private static void ReadNumberOfBases(GameState gameState)
    {
        gameState.NumberOfBasesPerPlayer = int.Parse(Console.ReadLine());
    }

    private static void ReadBases(GameState gameState, ICollection<Base> bases, ICollection<int> baseLocations)
    {
        var inputs = Console.ReadLine().Split(' ');
        for (var i = 0; i < gameState.NumberOfBasesPerPlayer; i++)
        {
            var baseIndex = int.Parse(inputs[i]);
            bases.Add(new Base { CellIndex = baseIndex });
            baseLocations.Add(baseIndex);
        }
    }

    public static GameState ReadInitialState()
    {
        var gameState = new GameState();
        ReadNumberOfCells(gameState);
        ReadInitialCellState(gameState);
        ReadNumberOfBases(gameState);
        ReadBases(gameState, gameState.MyBases, gameState.MyBaseLocations);
        ReadBases(gameState, gameState.EnemyBases, gameState.EnemyBaseLocations);

        return gameState;
    }

    public static void ReadStateUpdate(GameState gameState)
    {
        gameState.MyAntLookup.Clear();
        gameState.EnemyAntLookup.Clear();

        gameState.MyAntCount = 0;
        gameState.EnemyAntCount = 0;
        gameState.MyCrystalCount = 0;
        gameState.EnemyCrystalCount = 0;

        for (var i = 0; i < gameState.NumberOfCells; i++)
        {
            var inputs = Console.ReadLine().Split(' ');
            var resources = int.Parse(inputs[0]); // the current amount of eggs/crystals on this cell
            var myAnts = int.Parse(inputs[1]); // the amount of your ants on this cell
            var oppAnts = int.Parse(inputs[2]); // the amount of opponent ants on this cell

            gameState.Cells[i].Resources = resources;
            gameState.Cells[i].NumMyAnts = myAnts;
            gameState.Cells[i].NumEnemyAnts = oppAnts;

            if (resources == 0 && gameState.CrystalLocations.Contains(i))
            {
                gameState.CrystalLocations.Remove(i);
                gameState.ContestedCrystalLocations.Remove(i);
                gameState.MyCrystalLocations.Remove(i);
                gameState.EnemyCrystalLocations.Remove(i);
                gameState.Crystals.RemoveAll(x => x.CellIndex == i);
            }

            if (resources == 0 && gameState.EggLocations.Contains(i))
            {
                gameState.EggLocations.Remove(i);
                gameState.ContestedEggLocations.Remove(i);
                gameState.MyEggLocations.Remove(i);
                gameState.EnemyEggLocations.Remove(i);
                gameState.Eggs.RemoveAll(x => x.CellIndex == i);
            }

            if (myAnts > 0)
            {
                gameState.MyAntLookup[i] = myAnts;
                gameState.MyAntCount += myAnts;
            }

            if (oppAnts > 0)
            {
                gameState.EnemyAntLookup[i] = myAnts;
                gameState.EnemyAntCount += myAnts;
            }
        }
    }

    public static void DetermineOwnership(GameState gameState, PathFinder pathFinder)
    {
        var crystalContention = gameState.CrystalLocations.Select(index => pathFinder
            .ClosestOrDefault(index, gameState.EnemyBaseLocations)
            .Match(
                closestEnemyBase => pathFinder
                    .ClosestOrDefault(index, gameState.MyBaseLocations)
                    .Match(
                        closestMyBase => (index, isContested: closestEnemyBase.dist == closestMyBase.dist,
                            isMine: closestMyBase.dist < closestEnemyBase.dist),
                        _ => (index, isContested: true, isMine: false)
                    ),
                _ => (index, isContested: true, isMine: false)));

        foreach (var (index, isContested, isMine) in crystalContention)
        {
            if (isContested)
            {
                gameState.ContestedCrystalLocations.Add(index);
            }
            else if (isMine)
            {
                gameState.MyCrystalLocations.Add(index);
            }
            else
            {
                gameState.EnemyCrystalLocations.Add(index);
            }
        }

        var eggContention = gameState.EggLocations.Select(index => pathFinder
            .ClosestOrDefault(index, gameState.EnemyBaseLocations)
            .Match(
                closestEnemyBase => pathFinder
                    .ClosestOrDefault(index, gameState.MyBaseLocations)
                    .Match(
                        closestMyBase => (index, isContested: closestEnemyBase.dist == closestMyBase.dist,
                            isMine: closestMyBase.dist < closestEnemyBase.dist),
                        _ => (index, isContested: true, isMine: false)
                    ),
                _ => (index, isContested: true, isMine: false)));
        
        foreach (var (index, isContested, isMine) in eggContention)
        {
            if (isContested)
            {
                gameState.ContestedEggLocations.Add(index);
            }
            else if (isMine)
            {
                gameState.MyEggLocations.Add(index);
            }
            else
            {
                gameState.EnemyEggLocations.Add(index);
            }
        }
    }
}}

// Utils/Invalid.cs
namespace CodinGame_Spring_Challenge_2023.Utils{
public record Invalid();}

// Utils/NotFound.cs
namespace CodinGame_Spring_Challenge_2023.Utils{
public record NotFound();}

// Utils/NotFoundIndex.cs
namespace CodinGame_Spring_Challenge_2023.Utils{
public record NotFoundIndex
{
    public int Index { get; }
    
    public NotFoundIndex(int index)
    {
        Index = index;
    }
}}

// Utils/OneOf.cs
namespace CodinGame_Spring_Challenge_2023.Utils{
public class OneOf<T, U>
{
    private readonly T? _value1;
    private readonly U? _value2;
    
    public OneOf(T value)
    {
        _value1 = value;
    }
    
    public OneOf(U value)
    {
        _value2 = value;
    }
    
    public bool IsValue1 => _value1 != null;
    public bool IsValue2 => _value2 != null;
    
    public T Value1 => _value1!;
    public U Value2 => _value2!;
    
    public static implicit operator OneOf<T, U>(T value) => new (value);
    public static implicit operator OneOf<T, U>(U value) => new (value);
    
    public static implicit operator T(OneOf<T, U> oneOf) => oneOf.Value1;
    public static implicit operator U(OneOf<T, U> oneOf) => oneOf.Value2;
    
    public bool Is<TV>()
    {
        return typeof(TV) == typeof(T) == IsValue1;
    }
    
    public override string ToString()
    {
        return IsValue1 ? Value1.ToString() : Value2.ToString();
    }
    
    public override bool Equals(object? obj)
    {
        if (obj is OneOf<T, U> other)
        {
            if (IsValue1 && other.IsValue1)
            {
                return Value1.Equals(other.Value1);
            }
            else if (IsValue2 && other.IsValue2)
            {
                return Value2.Equals(other.Value2);
            }
        }
        
        return false;
    }
    
    public override int GetHashCode()
    {
        return IsValue1 ? Value1.GetHashCode() : Value2.GetHashCode();
    }
    
    public static bool operator ==(OneOf<T, U> left, OneOf<T, U> right)
    {
        return left.Equals(right);
    }
    
    public static bool operator !=(OneOf<T, U> left, OneOf<T, U> right)
    {
        return !(left == right);
    }
    
    public static bool operator ==(OneOf<T, U> left, T right)
    {
        return left.Equals(right);
    }
    
    public static bool operator !=(OneOf<T, U> left, T right)
    {
        return !(left == right);
    }
    
    public static bool operator ==(OneOf<T, U> left, U right)
    {
        return left.Equals(right);
    }
    
    public static bool operator !=(OneOf<T, U> left, U right)
    {
        return !(left == right);
    }
    
    public static bool operator ==(T left, OneOf<T, U> right)
    {
        return right.Equals(left);
    }
    
    public static bool operator !=(T left, OneOf<T, U> right)
    {
        return !(left == right);
    }
    
    public static bool operator ==(U left, OneOf<T, U> right)
    {
        return right.Equals(left);
    }
    
    public static bool operator !=(U left, OneOf<T, U> right)
    {
        return !(left == right);
    }
    
    public void Match(Action<T> value1Action, Action<U> value2Action)
    {
        if (IsValue1)
        {
            value1Action(Value1);
        }
        else
        {
            value2Action(Value2);
        }
    }
    
    public TV Match<TV>(Func<T, TV> value1Action, Func<U, TV> value2Action)
    {
        return IsValue1 ? value1Action(Value1) : value2Action(Value2);
    }
}}

// Domain/Base.cs
namespace CodinGame_Spring_Challenge_2023.Domain{
public class Base : IHaveCellIndex
{
    public int CellIndex { get; set; }
}}

// Domain/Cell.cs
namespace CodinGame_Spring_Challenge_2023.Domain{
public class Cell
{
    public CellType CellType { get; set; }
    public int Resources { get; set; }
    
    public int[] Neighbours { get; set; } = new int[6];

    public int NumAnts => NumMyAnts + NumEnemyAnts;
    public int NumMyAnts { get; set; }
    public int NumEnemyAnts { get; set; }
}}

// Domain/CellType.cs
namespace CodinGame_Spring_Challenge_2023.Domain{
public enum CellType
{
    Empty = 0,
    Eggs = 1,
    Crystal = 2
}}

// Domain/Crystal.cs
namespace CodinGame_Spring_Challenge_2023.Domain{
public class Crystal : IHaveCellIndex
{
    public int CellIndex { get; set; }
}}

// Domain/Egg.cs
namespace CodinGame_Spring_Challenge_2023.Domain{
public class Egg : IHaveCellIndex
{
    public int CellIndex { get; set; }
}}

// Domain/IHaveCellIndex.cs
namespace CodinGame_Spring_Challenge_2023.Domain{
public interface IHaveCellIndex
{
    int CellIndex { get; set; }
}}

// Strategy/StrategyCostBenefitAdaptive.cs
namespace CodinGame_Spring_Challenge_2023.Strategy{
public class StrategyCostBenefitAdaptive
{
    private GameState _gameState;
    private PathFinder _pathFinder;
    private MapInfo _mapInfo;
    private readonly ShortestTree _shortestTree;

    //private List<int> _currentlyVisiting = new();

    public StrategyCostBenefitAdaptive(GameState gameState, PathFinder pathFinder, MapInfo mapInfo, ShortestTree shortestTree)
    {
        _gameState = gameState;
        _pathFinder = pathFinder;
        _mapInfo = mapInfo;
        _shortestTree = shortestTree;
    }

    public OneOf<(int cost, float benefit), Invalid> CostBenefit(
        List<int> currentlyVisiting,
        int potentialLocation,
        bool isEgg,
        int currentNumAnts,
        List<int> eggsResourcesVisited,
        List<int> crystalResourcesVisited)
    {
        var averageCollectionRate = (float)currentNumAnts / currentlyVisiting.Count;
        var eggCollectionRate = eggsResourcesVisited.Count * averageCollectionRate;
        var crystalCollectionRate = crystalResourcesVisited.Count * averageCollectionRate;

        return _pathFinder.ClosestOrDefault(potentialLocation, currentlyVisiting)
            .Match<OneOf<(int cost, float benefit), Invalid>>(
                found =>
                {
                    var newAverageCollectionRate = (float)(currentNumAnts) / (currentlyVisiting.Count + found.dist);
                    if (isEgg)
                    {
                        newAverageCollectionRate = (currentNumAnts + newAverageCollectionRate) / (currentlyVisiting.Count + found.dist);
                    }

                    var newEggCollectionRate = (eggsResourcesVisited.Count + (isEgg ? 1 : 0)) * newAverageCollectionRate;
                    var newCrystalCollectionRate = (crystalResourcesVisited.Count + (isEgg ? 0 : 1)) * newAverageCollectionRate;
                    return (found.dist, newEggCollectionRate - eggCollectionRate + newCrystalCollectionRate - crystalCollectionRate);
                },
                _ => new Invalid());
    }

    public IEnumerable<int> Update()
    {
        /*
        _currentlyVisiting.RemoveAll(index => _gameState.Cells[index].Resources == 0);

        if (_currentlyVisiting.Count == 0)
        {
            _currentlyVisiting = _gameState.MyBaseLocations.ToList();
        }
        */

        var currentlyVisiting = _gameState.MyBaseLocations.ToList();
        while (true)
        {
            Console.Error.WriteLine("Strategy: Currently visiting: " + string.Join(",", currentlyVisiting));
            var potentialLocations = _gameState.CrystalLocations.Select(index => (index, isEgg: true)).ToList();
            var myVisitedEggLocations = currentlyVisiting.Where(x => _gameState.EggLocations.Contains(x)).ToList();
            var myVisitedCrystalLocations = currentlyVisiting.Where(x => _gameState.CrystalLocations.Contains(x)).ToList();

            if (!myVisitedEggLocations.Any())
            {
                potentialLocations.AddRange(_gameState.EggLocations.Select(index => (index, isEgg: false)));
            }

            potentialLocations.RemoveAll(x => currentlyVisiting.Contains(x.index));

            var costBenefits = potentialLocations.Select(x => (x.index, costBenefit: CostBenefit(currentlyVisiting, x.index,
                    x.isEgg, _gameState.MyAntCount,
                    myVisitedEggLocations, myVisitedCrystalLocations))).Where(x => x.costBenefit.IsValue1)
                .Select(x => (x.index, costBenefit: x.costBenefit.Value1))
                .OrderBy(x => -x.costBenefit.benefit).ToList();

            if (costBenefits.Any())
            {
                foreach (var result in costBenefits)
                {
                    Console.Error.WriteLine($"Strategy: Cost of going to {result.index} is {result.costBenefit.cost} and benefit is {result.costBenefit.benefit}");
                }
                
                var first = costBenefits.First();
                if (first.costBenefit.benefit > 0 || (myVisitedCrystalLocations.Count == 0 && myVisitedEggLocations.Count == 0))
                {
                    //Console.Error.WriteLine($"Strategy: Cost of going to {first.index} is {first.costBenefit.cost} and benefit is {first.costBenefit.benefit}");
                    var locations = _gameState.MyBaseLocations.Concat(myVisitedEggLocations)
                        .Concat(myVisitedCrystalLocations).Concat(new []{ first.index});
                    currentlyVisiting = ShortestTreeWalker.WalkShortestTree(_gameState,_pathFinder, _shortestTree.GetShortestTree(locations)).ToList();
                    continue;
                }
            }

            break;
        }

        return currentlyVisiting;

        //WFC of all possible states? We consider if we add each one and the cost/benefit.
        //AStar search maybe or all possible states and then we pick the best one?
        //Each addition takes away from the rest, so we look to find optimal


        /*
        var totalAnts = _gameState.MyAntCount;

        var locationsIncludedInStrategy = new HashSet<int>();
        var projectedEggCollection = 0;
        var projectedCrystalCollection = 0;

        var orderedLocations = _pathFinder.OrderedPairs(
            _gameState,
            _gameState.MyBaseLocations,
            (_gameState.EggLocations, CellType.Eggs),
            (_gameState.CrystalLocations, CellType.Crystal));

        foreach (var (fromIndex, toIndex, dist, cellType) in orderedLocations)
        {
            switch (cellType)
            {
                case CellType.Crystal:
                {
                    
                    break;
                }

                case CellType.Eggs:
                {
                    
                    
                    break;
                }
            }
        }
        return _gameState.MyBaseLocations;
        */

    }
}}

// PathFinding/MapInfo.cs
namespace CodinGame_Spring_Challenge_2023.PathFinding{
public class MapInfo
{
    private GameState _gameState;
    private PathFinder _pathFinder;

    public List<CellMapInfoDynamic> CellMapInfoDynamic { get; } = new();
    public List<CellMapInfoStatic> CellMapInfoStatic { get; } = new();

    public MapInfo(GameState gameState, PathFinder pathFinder)
    {
        _gameState = gameState;
        _pathFinder = pathFinder;
    }
    
    public void UpdateStatic()
    {
        if (CellMapInfoStatic.Count > 0) return;
        
        for (var i = 0; i < _gameState.NumberOfCells; ++i)
        {
            var cellMapInfoStatic = new CellMapInfoStatic
            {
                MyClosestBase = -1,
                EnemyClosestBase = -1
            };

            var closestDistances = _pathFinder.ClosestDistances(i, _gameState.MyBaseLocations);
            if (closestDistances.Any())
            {
                cellMapInfoStatic.MyClosestBase = closestDistances.First().index;
            }

            closestDistances = _pathFinder.ClosestDistances(i, _gameState.EnemyBaseLocations);
            if (closestDistances.Any())
            {
                cellMapInfoStatic.EnemyClosestBase = closestDistances.First().index;
            }
            
            CellMapInfoStatic.Add(cellMapInfoStatic);
            CellMapInfoDynamic.Add(new CellMapInfoDynamic());
        }
    }
    
    public void UpdateDynamic()
    {
        for (var i = 0; i < _gameState.NumberOfCells; ++i)
        {
            CellMapInfoDynamic[i].Resources = _gameState.Cells[i].Resources;
        }
    }
    
    public (CellMapInfoStatic staticInfo, CellMapInfoDynamic dynamicInfo) GetCellInfo(int cellIndex)
    {
        return (CellMapInfoStatic[cellIndex], CellMapInfoDynamic[cellIndex]);
    }
}

public record CellMapInfoStatic
{
    public int MyClosestBase;
    public int EnemyClosestBase;
}

public record CellMapInfoDynamic
{
    public int Resources;
}}

// PathFinding/PathFinder.cs
namespace CodinGame_Spring_Challenge_2023.PathFinding{
public class PathFinder
{
    private readonly int _numCells;

    private readonly List<Dictionary<int, (int dir, int dist)>> _cellPathMap =
        new List<Dictionary<int, (int dir, int dist)>>();

    private bool _fullyExpanded;

    private Action _onPathExpansionComplete;

    public PathFinder(GameState gameState)
    {
        _numCells = gameState.NumberOfCells;
        _onPathExpansionComplete = () => { };

        BuildPathInfo(gameState);
    }

    public PathFinder(List<Dictionary<int, (int dir, int dist)>> cellPathMap, int numCells)
    {
        _numCells = numCells;
        _cellPathMap = cellPathMap;
        _onPathExpansionComplete = () => { };
    }

    public void OnPathExpansionComplete(Action action)
    {
        _onPathExpansionComplete = action;
    }

    public bool ExpandPathKnowledge()
    {
        if (_fullyExpanded) return true;

        var newPathsFound = new List<(int from, int fromDir, int to, int toDir, int dist)>();

        for (var i = 0; i < _numCells; ++i)
        {
            var pathsForCell = _cellPathMap[i];

            foreach (var knownCellIndex in pathsForCell.Keys)
            {
                var pathToKnownCell = pathsForCell[knownCellIndex];
                var pathsForKnownCell = _cellPathMap[knownCellIndex];
                foreach (var otherCellIndex in pathsForKnownCell.Keys)
                {
                    if (i == otherCellIndex) continue;

                    var possibleDistViaKnownCell = pathToKnownCell.dist + pathsForKnownCell[otherCellIndex].dist;

                    if (pathsForCell.TryGetValue(otherCellIndex, out var myCurrentBestPathToOtherCell))
                    {
                        if (myCurrentBestPathToOtherCell.dist <= possibleDistViaKnownCell)
                        {
                            continue;
                        }
                    }

                    //We are new here or simply have a better path!
                    var pathsForOtherCell = _cellPathMap[otherCellIndex];
                    newPathsFound.Add((i, pathToKnownCell.dir, otherCellIndex, pathsForOtherCell[knownCellIndex].dir,
                        possibleDistViaKnownCell));
                }
            }
        }

        if (newPathsFound.Count == 0)
        {
            _fullyExpanded = true;
            _onPathExpansionComplete();
            return true;
        }

        foreach (var newPath in newPathsFound)
        {
            _cellPathMap[newPath.from][newPath.to] = (newPath.fromDir, newPath.dist);
            _cellPathMap[newPath.to][newPath.from] = (newPath.toDir, newPath.dist);
        }

        return false;
    }


    private void BuildPathInfo(GameState gameState)
    {
        for (var i = 0; i < gameState.NumberOfCells; ++i)
        {
            var pathsForCell = new Dictionary<int, (int dir, int dist)>();
            _cellPathMap.Add(pathsForCell);

            var cell = gameState.Cells[i];
            for (var dir = 0; dir < 6; ++dir)
            {
                var neighbourIndex = cell.Neighbours[dir];
                if (neighbourIndex == -1) continue;

                pathsForCell.Add(neighbourIndex, (dir, 1));
            }
        }
    }
    /*
for (var i = 0; i < _gameState.NumberOfCells; ++i)
    {
        var cell = _gameState.Cells[i];
        var pathsForCell = _cellPathMap[i];

        foreach (var pathToIndex in pathsForCell.Keys)
        {
            var knownCell = _gameState.Cells[pathToIndex];
            var pathsForKnownCell = _cellPathMap[pathToIndex];
            foreach (var otherPathToIndex in pathsForCell.Keys)
            {
                if (pathToIndex == otherPathToIndex) continue;

                if (!pathsForKnownCell.ContainsKey(otherPathToIndex))
                {
                    pathsForKnownCell[otherPathToIndex] = pathsForCell[pathToIndex].
                }   
            }
        }
    }
}
*/

    public IOrderedEnumerable<(int index, int dist)> ClosestDistances(int fromIndex, IEnumerable<int> toIndexList) =>
        toIndexList.Select(index => (index: index, dist: Distance(fromIndex, index))).Where((_, dist) => dist > -1)
            .OrderBy(x => x.dist);

    public OneOf<(int index, int dist), NotFound> ClosestOrDefault(int fromIndex, IEnumerable<int> toIndexList)
    {
        var closestDistances = ClosestDistances(fromIndex, toIndexList);
        if (closestDistances.Any())
        {
            return closestDistances.First();
        }

        return new NotFound();
    }

    public int Distance(int fromIndex, int toIndex)
    {
        if (_cellPathMap[fromIndex].TryGetValue(toIndex, out var path))
        {
            return path.dist;
        }

        return -1;
    }

    public IEnumerable<int> PathTo(GameState gameState, int fromIndex, int toIndex)
    {
        if (!_cellPathMap[fromIndex].ContainsKey(toIndex))
        {
            return Enumerable.Empty<int>();
        }

        var path = new List<int>();
        var currentCellIndex = fromIndex;
        while (currentCellIndex != toIndex)
        {
            path.Add(currentCellIndex);
            var nextCellDir = _cellPathMap[currentCellIndex][toIndex].dir;
            currentCellIndex = gameState.Cells[currentCellIndex].Neighbours[nextCellDir];
        }

        path.Add(toIndex);
        return path;
    }

    public IEnumerable<int> ClosestNOf(GameState gameState, int num, params IEnumerable<int>[] indexLists)
    {
        var closest = new List<int>();
        var closestDistances = new List<int>();
        foreach (var indexList in indexLists)
        {
            foreach (var index in indexList)
            {
                var dist = Distance(gameState.MyBases[0].CellIndex, index);
                if (dist == -1) continue;

                var indexToInsertAt = closestDistances.FindIndex(d => d > dist);
                if (indexToInsertAt == -1)
                {
                    indexToInsertAt = closest.Count;
                }

                closest.Insert(indexToInsertAt, index);
                closestDistances.Insert(indexToInsertAt, dist);
            }
        }

        return closest.Take(num);
    }

    public IOrderedEnumerable<(int fromIndex, int toIndex, int dist, CellType cellType)> OrderedPairs(GameState gameState,
        IEnumerable<int> fromList, params (IEnumerable<int>, CellType)[] indexLists)
    {
        var orderedPairs = (
            from fromIndex in fromList
            from list in indexLists
            from toIndex in list.Item1
            select (fromIndex, toIndex, dist: Distance(fromIndex, toIndex), cellType: list.Item2)
        ).ToList();

        return orderedPairs.OrderBy(x => x.dist);
    }

    public string DebugDistances(GameState gameState)
    {
        var output = "Distances from my base: ";
        foreach (var myBase in gameState.MyBases)
        {
            var crystalDistances = ClosestDistances(myBase.CellIndex, gameState.CrystalLocations);
            foreach (var crystal in crystalDistances)
            {
                output += $"({crystal.index}, {crystal.dist}) ";
            }
        }

        output += " Distances from enemy base: ";
        foreach (var enemyBase in gameState.EnemyBases)
        {
            var crystalDistances = ClosestDistances(enemyBase.CellIndex, gameState.CrystalLocations);
            foreach (var crystal in crystalDistances)
            {
                output += $"({crystal.index}, {crystal.dist}) ";
            }
        }

        return output;
    }

    public string DebugPaths(GameState gameState)
    {
        var output = "Paths from my base: ";
        foreach (var myBase in gameState.MyBases)
        {
            foreach (var crystal in gameState.CrystalLocations)
            {
                var path = PathTo(gameState, myBase.CellIndex, crystal);
                output += $"(Base({myBase.CellIndex}) -> Crystal({crystal}) : ";
                foreach (var step in path)
                {
                    output += step + " ";
                }
            }
        }

        output += " Paths from enemy base: ";
        foreach (var enemyBase in gameState.EnemyBases)
        {
            foreach (var crystal in gameState.CrystalLocations)
            {
                var path = PathTo(gameState, enemyBase.CellIndex, crystal);
                output += $"(Base({enemyBase.CellIndex}) -> Crystal({crystal}) : ";
                foreach (var step in path)
                {
                    output += step + " ";
                }
            }
        }

        return output;
    }
}}

// PathFinding/ShortestTree.cs
namespace CodinGame_Spring_Challenge_2023.PathFinding
{
    public class ShortestTree
    {
        private PathFinder _pathFinder;
        
        public ShortestTree(PathFinder pathFinder)
        {
            _pathFinder = pathFinder;
        }
        
        public IEnumerable<(int fromIndex, int toIndex)> GetShortestTree(IEnumerable<int> includeLocations)
        {
            var shortestTree = new List<(int fromIndex, int toIndex)>();
            
            var visited = new HashSet<int>();
            var unvisited = new HashSet<int>();
            foreach (var index in includeLocations)
            {
                unvisited.Add(index);
            }
            
            var currentCellIndex = unvisited.First();
            visited.Add(currentCellIndex);
            unvisited.Remove(currentCellIndex);
            
            while (unvisited.Count > 0)
            {
                var shortestPath = (fromIndex: -1, toIndex: -1, dist: int.MaxValue);
                foreach (var visitedCellIndex in visited)
                {
                    foreach (var unvisitedCellIndex in unvisited)
                    {
                        var dist = _pathFinder.Distance(unvisitedCellIndex, visitedCellIndex);
                        if (dist < 0) continue;
                        
                        if (dist < shortestPath.dist)
                        {
                            shortestPath = (visitedCellIndex, unvisitedCellIndex, dist);
                        }
                    }
                }
                
                shortestTree.Add((shortestPath.fromIndex, shortestPath.toIndex));
                
                visited.Add(shortestPath.toIndex);
                unvisited.Remove(shortestPath.toIndex);
            }
            
            return shortestTree;
        }
    }
}

// PathFinding/ShortestTreeWalker.cs
namespace CodinGame_Spring_Challenge_2023.PathFinding
{
    public static class ShortestTreeWalker
    {
        public static IEnumerable<int> WalkShortestTree(GameState gameState, PathFinder pathFinder,
            IEnumerable<(int fromIndex, int toIndex)> tree) => tree
            .SelectMany(x => pathFinder.PathTo(gameState, x.fromIndex, x.toIndex)).Distinct();
    }
}
