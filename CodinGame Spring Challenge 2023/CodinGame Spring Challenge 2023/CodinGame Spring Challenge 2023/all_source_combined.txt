// File generated by dotnet-combine at 2023-05-27__17_23_24

using System;
using System.Collections.Generic;
using System.Linq;




public class Base : IHaveCellIndex
{
    public int CellIndex { get; set; }
}


public class Cell
{
    public CellType CellType { get; set; }
    public int Resources { get; set; }
    
    public int[] Neighbours { get; set; } = new int[6];

    public int NumAnts => NumMyAnts + NumEnemyAnts;
    public int NumMyAnts { get; set; }
    public int NumEnemyAnts { get; set; }
}

public enum CellType
{
    Empty = 0,
    Eggs = 1,
    Crystal = 2
}


public class GameActions
{
    private List<string> Actions { get; set; } = new List<string>();

    public GameActions()
    {
    }

    public void FlushMoves()
    {
        Console.WriteLine(string.Join(";", Actions));
    }
    
    // WAIT | LINE <sourceIdx> <targetIdx> <strength> | BEACON <cellIdx> <strength> | MESSAGE <text>
    public void Wait()
    {
        Actions.Add("WAIT");
    }
        
    public void Line(int sourceIdx, int targetIdx, int strength)
    {
        Actions.Add($"LINE {sourceIdx} {targetIdx} {strength}");
    }
        
    public void Beacon(int cellIdx, int strength)
    {
        Actions.Add($"BEACON {cellIdx} {strength}");
    }
        
    public void Message(string text)
    {
        Actions.Add($"MESSAGE {text}");
    }
}


public class GameState
{
    public int NumberOfCells { get; set; }
    public int NumberOfBasesPerPlayer { get; set; }
    public List<Base> MyBases { get; set; } = new List<Base>();
    public List<Base> EnemyBases { get; set; } = new List<Base>();
    public List<Cell> Cells { get; set; } = new List<Cell>();
    
    public List<int> CrystalLocations { get; set; } = new List<int>();
}


public class GameStateReader
{
    private void ReadNumberOfCells(GameState gameState)
    {
        // amount of hexagonal cells in this map
        gameState.NumberOfCells = int.Parse(Console.ReadLine());
    }

    private void ReadInitialCellState(GameState gameState)
    {
        for (var i = 0; i < gameState.NumberOfCells; i++)
        {
            var inputs = Console.ReadLine().Split(' ');
            var type = (CellType) int.Parse(inputs[0]); // 0 for empty, 1 for eggs, 2 for crystal
            var initialResources = int.Parse(inputs[1]); // the initial amount of eggs/crystals on this cell
            var neigh0 = int.Parse(inputs[2]); // the index of the neighbouring cell for each direction
            var neigh1 = int.Parse(inputs[3]);
            var neigh2 = int.Parse(inputs[4]);
            var neigh3 = int.Parse(inputs[5]);
            var neigh4 = int.Parse(inputs[6]);
            var neigh5 = int.Parse(inputs[7]);

            gameState.Cells.Add(new Cell
            {
                CellType = type,
                Resources = initialResources,
                Neighbours = new[] { neigh0, neigh1, neigh2, neigh3, neigh4, neigh5 }
            });
            
            if (type == CellType.Crystal)
            {
                gameState.CrystalLocations.Add(i);
            }
        }
    }

    private void ReadNumberOfBases(GameState gameState)
    {
        gameState.NumberOfBasesPerPlayer = int.Parse(Console.ReadLine());
    }

    private void ReadBases(GameState gameState, ICollection<Base> bases)
    {
        var inputs = Console.ReadLine().Split(' ');
        for (var i = 0; i < gameState.NumberOfBasesPerPlayer; i++)
        {
            bases.Add(new Base() { CellIndex = int.Parse(inputs[i]) });
        }
    }

    public GameState ReadInitialState()
    {
        var gameState = new GameState();
        ReadNumberOfCells(gameState);
        ReadInitialCellState(gameState);
        ReadNumberOfBases(gameState);
        ReadBases(gameState, gameState.MyBases);
        ReadBases(gameState, gameState.EnemyBases);

        return gameState;
    }

    public void ReadStateUpdate(GameState gameState)
    {
        for (var i = 0; i < gameState.NumberOfCells; i++)
        {
            var inputs = Console.ReadLine().Split(' ');
            var resources = int.Parse(inputs[0]); // the current amount of eggs/crystals on this cell
            var myAnts = int.Parse(inputs[1]); // the amount of your ants on this cell
            var oppAnts = int.Parse(inputs[2]); // the amount of opponent ants on this cell
            
            gameState.Cells[i].Resources = resources;
            gameState.Cells[i].NumMyAnts = myAnts;
            gameState.Cells[i].NumEnemyAnts = oppAnts;
            
            if (resources == 0 && gameState.CrystalLocations.Contains(i))
            {
                gameState.CrystalLocations.Remove(i);
            }
        }
    }
}

public interface IHaveCellIndex
{
    int CellIndex { get; set; }
}


public class Path
{
    public List<int> Steps { get; set; }
    public int Distance => Steps.Count + 1;
}


public class PathFinder
{
    private GameState _gameState;

    private List<Dictionary<int, (int dir, int dist)>> _cellPathMap = new List<Dictionary<int, (int dir, int dist)>>();

    private bool fullyExpanded = false;

    public PathFinder(GameState gameState)
    {
        _gameState = gameState;

        BuildPathInfo();
    }

    public void ExpandPathKnowledge()
    {
        if (fullyExpanded) return;

        var newPathsFound = new List<(int from, int fromDir, int to, int toDir, int dist)>();

        for (var i = 0; i < _gameState.NumberOfCells; ++i)
        {
            var pathsForCell = _cellPathMap[i];

            foreach (var knownCellIndex in pathsForCell.Keys)
            {
                var pathToKnownCell = pathsForCell[knownCellIndex];
                var pathsForKnownCell = _cellPathMap[knownCellIndex];
                foreach (var otherCellIndex in pathsForKnownCell.Keys)
                {
                    if (i == otherCellIndex) continue;

                    var possibleDistViaKnownCell = pathToKnownCell.dist + pathsForKnownCell[otherCellIndex].dist;

                    if (pathsForCell.TryGetValue(otherCellIndex, out var myCurrentBestPathToOtherCell))
                    {
                        if (myCurrentBestPathToOtherCell.dist < possibleDistViaKnownCell)
                        {
                            continue;
                        }
                    }

                    //We are new here or simply have a better path!
                    var pathsForOtherCell = _cellPathMap[otherCellIndex];
                    newPathsFound.Add((i, pathToKnownCell.dir, otherCellIndex, pathsForOtherCell[knownCellIndex].dir,
                        possibleDistViaKnownCell));
                }
            }
        }

        if (newPathsFound.Count == 0)
        {
            fullyExpanded = true;
            return;
        }

        foreach (var newPath in newPathsFound)
        {
            _cellPathMap[newPath.from][newPath.to] = (newPath.fromDir, newPath.dist);
            _cellPathMap[newPath.to][newPath.from] = (newPath.toDir, newPath.dist);
        }
    }


    private void BuildPathInfo()
    {
        for (var i = 0; i < _gameState.NumberOfCells; ++i)
        {
            var pathsForCell = new Dictionary<int, (int dir, int dist)>();
            _cellPathMap.Add(pathsForCell);

            var cell = _gameState.Cells[i];
            for (var dir = 0; dir < 6; ++dir)
            {
                var neighbourIndex = cell.Neighbours[dir];
                if (neighbourIndex == -1) continue;

                pathsForCell.Add(neighbourIndex, (dir, 1));
            }
        }
    }
    /*
    for (var i = 0; i < _gameState.NumberOfCells; ++i)
        {
            var cell = _gameState.Cells[i];
            var pathsForCell = _cellPathMap[i];

            foreach (var pathToIndex in pathsForCell.Keys)
            {
                var knownCell = _gameState.Cells[pathToIndex];
                var pathsForKnownCell = _cellPathMap[pathToIndex];
                foreach (var otherPathToIndex in pathsForCell.Keys)
                {
                    if (pathToIndex == otherPathToIndex) continue;

                    if (!pathsForKnownCell.ContainsKey(otherPathToIndex))
                    {
                        pathsForKnownCell[otherPathToIndex] = pathsForCell[pathToIndex].
                    }   
                }
            }
        }
    }
    */

    public IOrderedEnumerable<(int index, int dist)> ClosestDistances(int fromIndex, IEnumerable<IHaveCellIndex> toIndexList) =>
        toIndexList.Select(index => (index: index.CellIndex, dist: Distance(fromIndex, index.CellIndex))).Where((_, dist) => dist > -1)
            .OrderBy(x => x.dist);

    public (int index, int dist) ClosestOrDefault(int fromIndex, IEnumerable<IHaveCellIndex> toIndexList)
    {
        var closestDistances = ClosestDistances(fromIndex, toIndexList);
        if (closestDistances.Any())
        {
            return closestDistances.First();
        }
        
        return (-1, -1);
    }
    
    public int Distance(int fromIndex, int toIndex)
    {
        if (_cellPathMap[fromIndex].TryGetValue(toIndex, out var path))
        {
            return path.dist;
        }

        return -1;
    }
}


public static class Player
{
    static void Main(string[] args)
    {
        var gameActions = new GameActions();
        var gameStateReader = new GameStateReader();
        var gameState = gameStateReader.ReadInitialState();
        var pathFinder = new PathFinder(gameState);

        // game looping
        while (true)
        {
            gameStateReader.ReadStateUpdate(gameState);

            var hasMoves = false;
            var myClosestWeight = 0.7;
            var enemyClosestWeight = 0.3;
            var strengthToUseForMyCrystals = 2;
            var strengthToUseForEnemyCrystals = 1;

            var myClosestCrystals = gameState.CrystalLocations
                .Select(crystalIndex => (crystalIndex,
                    distForMe: pathFinder.ClosestOrDefault(crystalIndex, gameState.MyBases),
                    distForEnemy: pathFinder.ClosestOrDefault(crystalIndex, gameState.EnemyBases)))
                .Where(x => x.distForMe.index != -1)
                .Select(
                    x => (x.crystalIndex,
                        baseIndex: x.distForMe.index,
                        closerToEnemy: x.distForEnemy.index > -1 && x.distForEnemy.dist < x.distForMe.dist,
                        weightedDist: x.distForMe.dist * myClosestWeight + (x.distForEnemy.index > -1 ? 100 : x.distForEnemy.dist) *
                        enemyClosestWeight)).OrderBy(x => x.weightedDist);

            var hasGoneToOneOfMyCrystals = false;
            var hasGoneToOneOfEnemyCrystals = false;
            
            foreach (var crystal in myClosestCrystals)
            {
                if (crystal.closerToEnemy)
                {
                    gameActions.Line(crystal.baseIndex, crystal.crystalIndex, strengthToUseForEnemyCrystals);
                    hasGoneToOneOfEnemyCrystals = true;
                }
                else
                {
                    gameActions.Line(crystal.baseIndex, crystal.crystalIndex, strengthToUseForMyCrystals);
                    hasGoneToOneOfMyCrystals = true;
                }
                
                if (hasGoneToOneOfEnemyCrystals && hasGoneToOneOfMyCrystals)
                {
                    break;
                }
            }

            if (!hasMoves)
            {
                gameActions.Wait();
            }

            // Write an action us Console.WriteLine()
            // To debug: Console.Error.WriteLine("Debug messages...");
            gameActions.FlushMoves();
        }
    }
}
