// File generated by dotnet-combine at 2023-06-02__19_40_30

using CodinGame_Spring_Challenge_2023.Core;
using CodinGame_Spring_Challenge_2023.Domain;
using CodinGame_Spring_Challenge_2023.PathFinding;
using CodinGame_Spring_Challenge_2023.Strategy;
using CodinGame_Spring_Challenge_2023.Utils;
using System;
using System.Collections.Generic;
using System.Linq;



// Player.cs
namespace CodinGame_Spring_Challenge_2023{
public static class Player
{
    static void Main(string[] args)
    {
        var gameActions = new GameActions();
        var gameState = GameStateReader.ReadInitialState();

        var startTime = DateTime.UtcNow;
        var pathFinder = new PathFinder(gameState);
        var shortestTree = new ShortestTree(pathFinder);
        var mapInfo = new MapInfo(gameState, pathFinder);
        var strategyCostBenefitAdaptive = new StrategyCostBenefitAdaptive(gameState, pathFinder, shortestTree);
        var strategyAssessWinConditions = new StrategyAssessWinConditions(gameState, pathFinder);

        pathFinder.OnPathExpansionComplete(() =>
        {
            Console.Error.WriteLine("OnPathExpansionComplete");
            Console.Error.WriteLine("DebugDistances: " + pathFinder.DebugDistances(gameState));
            Console.Error.WriteLine("DebugPaths: " + pathFinder.DebugPaths(gameState));
            GameStateReader.DetermineOwnership(gameState, pathFinder);
            mapInfo.UpdateStatic();
        });

        var maxLoops = 20;
        while (!pathFinder.ExpandPathKnowledge() && --maxLoops > 0)
        {
        }

        if (maxLoops == 0)
        {
            Console.Error.WriteLine("Could not complete path map, will update each frame but may not be optimal");
        }

        Console.Error.WriteLine($"[StartUp]Frame time: {(DateTime.UtcNow - startTime).TotalMilliseconds}ms");
        
        // game looping
        while (true)
        {
            GameStateReader.ReadStateUpdate(gameState);
            var frameStart = DateTime.UtcNow;
            
            Console.Error.WriteLine(
                $"Resources: {string.Join(",", gameState.Cells.ToList().Select((cell, index) => (cell.Resources, text: $"({index},{cell.Resources})")).Where(x => x.Resources > 0).Select(x => x.text))}");

            pathFinder.ExpandPathKnowledge();
            strategyAssessWinConditions.Update();

            var locations = strategyCostBenefitAdaptive.Update(strategyAssessWinConditions.ProjectedTurnsUntilGameEnds);
            foreach (var index in locations)
            {
                gameActions.Beacon(index, gameState.Cells[index].NumEnemyAnts > 0 ? 2 : 1);
            }

            gameActions.FlushMoves();

            var frameEndTime = DateTime.UtcNow;
            var frameTime = frameEndTime - frameStart;
            Console.Error.WriteLine($"[End]Frame time: {frameTime.TotalMilliseconds}ms");
        }
    }
}}

// Core/GameActions.cs
namespace CodinGame_Spring_Challenge_2023.Core{
public class GameActions
{
    private const bool ShowDebug = true;
    
    private List<string> Actions { get; set; } = new List<string>();

    public GameActions()
    {
    }

    public void FlushMoves()
    {
        if (Actions.Count == 0)
        {
            Wait();
        }
        
        Console.WriteLine(string.Join(";", Actions));
        
        Actions.Clear();
    }
    
    // WAIT | LINE <sourceIdx> <targetIdx> <strength> | BEACON <cellIdx> <strength> | MESSAGE <text>
    public void Wait()
    {
        Actions.Add("WAIT");
    }
        
    public void Line(int sourceIdx, int targetIdx, int strength, string message = null)
    {
        DebugMessage(message);
        Actions.Add($"LINE {sourceIdx} {targetIdx} {strength}");
    }
        
    public void Beacon(int cellIdx, int strength, string message = null)
    {
        DebugMessage(message);
        Actions.Add($"BEACON {cellIdx} {strength}");
    }
        
    public void Message(string text)
    {
        Actions.Add($"MESSAGE {text}");
    }

    public void DebugMessage(string message)
    {
        if (!ShowDebug || message == null) return;
        
        Message(message);
    }
}}

// Core/GameState.cs
namespace CodinGame_Spring_Challenge_2023.Core{
public class GameState
{
    public int NumberOfCells { get; set; }
    public int NumberOfBasesPerPlayer { get; set; }
    
    public int MyAntCount { get; set; }
    public int EnemyAntCount { get; set; }
    
    public int MyCrystalCount { get; set; }
    public int EnemyCrystalCount { get; set; }
    
    public List<Base> MyBases { get; set; } = new ();
    public List<Base> EnemyBases { get; set; } = new ();
    public List<Cell> Cells { get; set; } = new ();
    public List<Crystal> Crystals { get; set; } = new ();
    public List<Egg> Eggs { get; set; } = new ();
    
    public List<int> MyBaseLocations { get; set; } = new ();
    public List<int> EnemyBaseLocations { get; set; } = new ();
    public List<int> CrystalLocations { get; set; } = new ();
    public List<int> EggLocations { get; set; } = new ();
    public List<int> MyCrystalLocations { get; set; } = new ();
    public List<int> EnemyCrystalLocations { get; set; } = new ();
    public List<int> MyEggLocations { get; set; } = new ();
    public List<int> EnemyEggLocations { get; set; } = new ();
    public List<int> ContestedCrystalLocations { get; set; } = new ();
    public List<int> ContestedEggLocations { get; set; } = new ();

    public Dictionary<int, int> MyAntLookup { get; set; } = new ();

    public Dictionary<int, int> EnemyAntLookup { get; set; } = new ();
    
    public StrategyType Strategy { get; set; }
    
    public float StrategyStrength { get; set; }
}}

// Core/GameStateReader.cs
namespace CodinGame_Spring_Challenge_2023.Core{
public static class GameStateReader
{
    private static void ReadNumberOfCells(GameState gameState)
    {
        // amount of hexagonal cells in this map
        gameState.NumberOfCells = int.Parse(Console.ReadLine());
    }

    private static void ReadInitialCellState(GameState gameState)
    {
        for (var i = 0; i < gameState.NumberOfCells; i++)
        {
            var inputs = Console.ReadLine().Split(' ');
            var type = (CellType)int.Parse(inputs[0]); // 0 for empty, 1 for eggs, 2 for crystal
            var initialResources = int.Parse(inputs[1]); // the initial amount of eggs/crystals on this cell
            var neigh0 = int.Parse(inputs[2]); // the index of the neighbouring cell for each direction
            var neigh1 = int.Parse(inputs[3]);
            var neigh2 = int.Parse(inputs[4]);
            var neigh3 = int.Parse(inputs[5]);
            var neigh4 = int.Parse(inputs[6]);
            var neigh5 = int.Parse(inputs[7]);

            gameState.Cells.Add(new Cell
            {
                CellType = type,
                Resources = initialResources,
                Neighbours = new[] { neigh0, neigh1, neigh2, neigh3, neigh4, neigh5 }
            });

            if (type == CellType.Crystal)
            {
                gameState.Crystals.Add(new Crystal { CellIndex = i });
                gameState.CrystalLocations.Add(i);
            }

            if (type == CellType.Eggs)
            {
                gameState.Eggs.Add(new Egg { CellIndex = i });
                gameState.EggLocations.Add(i);
            }
        }
    }

    private static void ReadNumberOfBases(GameState gameState)
    {
        gameState.NumberOfBasesPerPlayer = int.Parse(Console.ReadLine());
    }

    private static void ReadBases(GameState gameState, ICollection<Base> bases, ICollection<int> baseLocations)
    {
        var inputs = Console.ReadLine().Split(' ');
        for (var i = 0; i < gameState.NumberOfBasesPerPlayer; i++)
        {
            var baseIndex = int.Parse(inputs[i]);
            bases.Add(new Base { CellIndex = baseIndex });
            baseLocations.Add(baseIndex);
        }
    }

    public static GameState ReadInitialState()
    {
        var gameState = new GameState();
        ReadNumberOfCells(gameState);
        ReadInitialCellState(gameState);
        ReadNumberOfBases(gameState);
        ReadBases(gameState, gameState.MyBases, gameState.MyBaseLocations);
        ReadBases(gameState, gameState.EnemyBases, gameState.EnemyBaseLocations);

        return gameState;
    }

    public static void ReadStateUpdate(GameState gameState)
    {
        gameState.MyAntLookup.Clear();
        gameState.EnemyAntLookup.Clear();

        gameState.MyAntCount = 0;
        gameState.EnemyAntCount = 0;
        gameState.MyCrystalCount = 0;
        gameState.EnemyCrystalCount = 0;

        for (var i = 0; i < gameState.NumberOfCells; i++)
        {
            var inputs = Console.ReadLine().Split(' ');
            var resources = int.Parse(inputs[0]); // the current amount of eggs/crystals on this cell
            var myAnts = int.Parse(inputs[1]); // the amount of your ants on this cell
            var oppAnts = int.Parse(inputs[2]); // the amount of opponent ants on this cell

            gameState.Cells[i].Resources = resources;
            gameState.Cells[i].NumMyAnts = myAnts;
            gameState.Cells[i].NumEnemyAnts = oppAnts;

            if (resources == 0 && gameState.CrystalLocations.Contains(i))
            {
                gameState.CrystalLocations.Remove(i);
                gameState.ContestedCrystalLocations.Remove(i);
                gameState.MyCrystalLocations.Remove(i);
                gameState.EnemyCrystalLocations.Remove(i);
                gameState.Crystals.RemoveAll(x => x.CellIndex == i);
            }

            if (resources == 0 && gameState.EggLocations.Contains(i))
            {
                gameState.EggLocations.Remove(i);
                gameState.ContestedEggLocations.Remove(i);
                gameState.MyEggLocations.Remove(i);
                gameState.EnemyEggLocations.Remove(i);
                gameState.Eggs.RemoveAll(x => x.CellIndex == i);
            }

            if (myAnts > 0)
            {
                gameState.MyAntLookup[i] = myAnts;
                gameState.MyAntCount += myAnts;
            }

            if (oppAnts > 0)
            {
                gameState.EnemyAntLookup[i] = myAnts;
                gameState.EnemyAntCount += myAnts;
            }
        }
    }

    public static void DetermineOwnership(GameState gameState, PathFinder pathFinder)
    {
        var crystalContention = gameState.CrystalLocations.Select(index => pathFinder
            .ClosestOrDefault(index, gameState.EnemyBaseLocations)
            .Match(
                closestEnemyBase => pathFinder
                    .ClosestOrDefault(index, gameState.MyBaseLocations)
                    .Match(
                        closestMyBase => (index, isContested: closestEnemyBase.dist == closestMyBase.dist,
                            isMine: closestMyBase.dist < closestEnemyBase.dist),
                        _ => (index, isContested: true, isMine: false)
                    ),
                _ => (index, isContested: true, isMine: false)));

        foreach (var (index, isContested, isMine) in crystalContention)
        {
            if (isContested)
            {
                gameState.ContestedCrystalLocations.Add(index);
            }
            else if (isMine)
            {
                gameState.MyCrystalLocations.Add(index);
            }
            else
            {
                gameState.EnemyCrystalLocations.Add(index);
            }
        }

        var eggContention = gameState.EggLocations.Select(index => pathFinder
            .ClosestOrDefault(index, gameState.EnemyBaseLocations)
            .Match(
                closestEnemyBase => pathFinder
                    .ClosestOrDefault(index, gameState.MyBaseLocations)
                    .Match(
                        closestMyBase => (index, isContested: closestEnemyBase.dist == closestMyBase.dist,
                            isMine: closestMyBase.dist < closestEnemyBase.dist),
                        _ => (index, isContested: true, isMine: false)
                    ),
                _ => (index, isContested: true, isMine: false)));
        
        foreach (var (index, isContested, isMine) in eggContention)
        {
            if (isContested)
            {
                gameState.ContestedEggLocations.Add(index);
            }
            else if (isMine)
            {
                gameState.MyEggLocations.Add(index);
            }
            else
            {
                gameState.EnemyEggLocations.Add(index);
            }
        }
    }
}}

// Core/StrategyType.cs
namespace CodinGame_Spring_Challenge_2023.Core{
public enum StrategyType
{
    CollectEggs,
    CollectCrystals
}}

// Utils/Invalid.cs
namespace CodinGame_Spring_Challenge_2023.Utils{
public record Invalid();}

// Utils/NotFound.cs
namespace CodinGame_Spring_Challenge_2023.Utils{
public record NotFound();}

// Utils/NotFoundIndex.cs
namespace CodinGame_Spring_Challenge_2023.Utils{
public record NotFoundIndex
{
    public int Index { get; }
    
    public NotFoundIndex(int index)
    {
        Index = index;
    }
}}

// Utils/OneOf.cs
namespace CodinGame_Spring_Challenge_2023.Utils{
public class OneOf<T, U>
{
    private readonly bool _isValue1;

    public OneOf(T value)
    {
        Value1 = value;
        _isValue1 = true;
    }
    
    public OneOf(U value)
    {
        Value2 = value;
        _isValue1 = false;
    }
    
    public bool IsValue1 => _isValue1;
    public bool IsValue2 => !_isValue1;
    
    public T Value1 { get; }

    public U Value2 { get; }

    public static implicit operator OneOf<T, U>(T value) => new (value);
    public static implicit operator OneOf<T, U>(U value) => new (value);
    
    public static implicit operator T(OneOf<T, U> oneOf) => oneOf.Value1;
    public static implicit operator U(OneOf<T, U> oneOf) => oneOf.Value2;
    
    public bool Is<TV>()
    {
        return (typeof(TV) == typeof(T) && IsValue1) || (typeof(TV) == typeof(U) && IsValue2);
    }
    
    public override string ToString()
    {
        return IsValue1 ? Value1.ToString() : Value2.ToString();
    }
    
    public override bool Equals(object? obj)
    {
        if (obj is OneOf<T, U> other)
        {
            if (IsValue1 && other.IsValue1)
            {
                return Value1.Equals(other.Value1);
            }
            else if (IsValue2 && other.IsValue2)
            {
                return Value2.Equals(other.Value2);
            }
        }
        
        return false;
    }
    
    public override int GetHashCode()
    {
        return IsValue1 ? Value1.GetHashCode() : Value2.GetHashCode();
    }
    
    public static bool operator ==(OneOf<T, U> left, OneOf<T, U> right)
    {
        return left.Equals(right);
    }
    
    public static bool operator !=(OneOf<T, U> left, OneOf<T, U> right)
    {
        return !(left == right);
    }
    
    public static bool operator ==(OneOf<T, U> left, T right)
    {
        return left.Equals(right);
    }
    
    public static bool operator !=(OneOf<T, U> left, T right)
    {
        return !(left == right);
    }
    
    public static bool operator ==(OneOf<T, U> left, U right)
    {
        return left.Equals(right);
    }
    
    public static bool operator !=(OneOf<T, U> left, U right)
    {
        return !(left == right);
    }
    
    public static bool operator ==(T left, OneOf<T, U> right)
    {
        return right.Equals(left);
    }
    
    public static bool operator !=(T left, OneOf<T, U> right)
    {
        return !(left == right);
    }
    
    public static bool operator ==(U left, OneOf<T, U> right)
    {
        return right.Equals(left);
    }
    
    public static bool operator !=(U left, OneOf<T, U> right)
    {
        return !(left == right);
    }
    
    public void Match(Action<T> value1Action, Action<U> value2Action)
    {
        if (IsValue1)
        {
            value1Action(Value1);
        }
        else
        {
            value2Action(Value2);
        }
    }
    
    public TV Match<TV>(Func<T, TV> value1Action, Func<U, TV> value2Action)
    {
        return IsValue1 ? value1Action(Value1) : value2Action(Value2);
    }
}}

// Utils/OneOrMany.cs
namespace CodinGame_Spring_Challenge_2023.Utils{
public class OneOrMany<T> : OneOf<T, IList<T>> where T : IEquatable<T>
{
    public OneOrMany(T value) : base(value)
    {
    }

    public OneOrMany(IList<T> value) : base(value)
    {
    }
    
    public static implicit operator OneOrMany<T>(T value) => new (value);

    public static OneOrMany<T> FromIList(IList<T> value) => new (value);

    public static implicit operator T(OneOrMany<T> oneOf) => oneOf.Value1;

    public static IList<T> ToIList(OneOrMany<T> oneOf) => oneOf.Value2;

    public OneOrMany<T> Merge(OneOrMany<T> other)
    {
        var combinedList = new List<T>();
        Match(
            mySingleResult => combinedList.Add(mySingleResult),
            multipleResult => combinedList.AddRange(multipleResult));

        other.Match(
            mySingleResult =>
            {
                if (combinedList.Contains(mySingleResult)) return;
                combinedList.Add(mySingleResult);
            },
            multipleResult => combinedList
                .AddRange(multipleResult.Where(x => !combinedList.Contains(x))));

        return combinedList.Count == 1 ? new OneOrMany<T>(combinedList[0]) : new OneOrMany<T>(combinedList);
    }

    public bool IsEquivalent(OneOrMany<T> other)
    {
        if (IsValue1 != other.IsValue1) return false;

        return Match(
            singleResult => singleResult.Equals(other.Value1),
            multipleResult => multipleResult.Count == other.Value2.Count && multipleResult.All(x => other.Value2.Contains(x)));
    }
    
    public override string ToString()
    {
        return IsValue1 ? "One["+ Value1 +"]" : "Many[" + string.Join(",", Value2.Select(x => x.ToString())) + "]";
    }
}}

// Domain/Base.cs
namespace CodinGame_Spring_Challenge_2023.Domain{
public class Base : IHaveCellIndex
{
    public int CellIndex { get; set; }
}}

// Domain/Cell.cs
namespace CodinGame_Spring_Challenge_2023.Domain{
public class Cell
{
    public CellType CellType { get; set; }
    public int Resources { get; set; }
    
    public int[] Neighbours { get; set; } = new int[6];

    public int NumAnts => NumMyAnts + NumEnemyAnts;
    public int NumMyAnts { get; set; }
    public int NumEnemyAnts { get; set; }
}}

// Domain/CellType.cs
namespace CodinGame_Spring_Challenge_2023.Domain{
public enum CellType
{
    Empty = 0,
    Eggs = 1,
    Crystal = 2
}}

// Domain/Crystal.cs
namespace CodinGame_Spring_Challenge_2023.Domain{
public class Crystal : IHaveCellIndex
{
    public int CellIndex { get; set; }
}}

// Domain/Egg.cs
namespace CodinGame_Spring_Challenge_2023.Domain{
public class Egg : IHaveCellIndex
{
    public int CellIndex { get; set; }
}}

// Domain/IHaveCellIndex.cs
namespace CodinGame_Spring_Challenge_2023.Domain{
public interface IHaveCellIndex
{
    int CellIndex { get; set; }
}}

// Strategy/StrategyAssessWinConditions.cs
namespace CodinGame_Spring_Challenge_2023.Strategy{
public class StrategyAssessWinConditions
{
    private readonly GameState _gameState;
    private readonly PathFinder _pathFinder;
    private readonly int _startingCrystalResources;
    private int _numFrames;

    public int ProjectedTurnsUntilGameEnds { get; private set; }

    public StrategyAssessWinConditions(GameState gameState, PathFinder pathFinder)
    {
        _gameState = gameState;
        _pathFinder = pathFinder;
        _startingCrystalResources = _gameState.CrystalLocations.Sum(x => _gameState.Cells[x].Resources);
        ProjectedTurnsUntilGameEnds = 100;
        _numFrames = 0;
    }

    public void Update()
    {
        ++_numFrames;

        var remainingCrystalResources = (float)_gameState.CrystalLocations.Sum(x => _gameState.Cells[x].Resources);
        var consumedCrystalResources = _startingCrystalResources - remainingCrystalResources;
        consumedCrystalResources = Math.Max(1f, consumedCrystalResources);

        var consumptionRate = consumedCrystalResources / _numFrames;

        ProjectedTurnsUntilGameEnds =
            (int)Math.Max(2f, Math.Min(100f, 0.5f * remainingCrystalResources / consumptionRate));

        GenerateCrystalVsEggStrategy();
    }

    private void GenerateCrystalVsEggStrategy()
    {
        var totalEggs = _gameState.EggLocations.Sum(index => _gameState.Cells[index].Resources);
        var totalCrystals = _gameState.CrystalLocations.Sum(index => _gameState.Cells[index].Resources);
        var averageEggDist = (float) _gameState.EggLocations
            .Select(index => _pathFinder.ClosestOrDefault(index, _gameState.MyBaseLocations))
            .Where(x => x.IsValue1)
            .Average(x => x.Value1.dist);
        var averageCrystalDist = (float) _gameState.CrystalLocations
            .Select(index => _pathFinder.ClosestOrDefault(index, _gameState.MyBaseLocations))
            .Where(x => x.IsValue1)
            .Average(x => x.Value1.dist);

        var target = 1 + totalCrystals / 2;

        float CountFramesToWinFocusingOnEggs(float frameCount, float remainingTarget, float numAnts, float remainingEggs)
        {
            while (true)
            {
                if (remainingTarget <= 0) return frameCount;

                var eggsCollected = numAnts / averageEggDist;
                if (eggsCollected >= remainingEggs)
                {
                    var newNumAnts = numAnts + remainingEggs;
                    var crystalsCollectedPerFrame = newNumAnts / averageEggDist;
                    return frameCount + remainingTarget / crystalsCollectedPerFrame;
                }

                frameCount = frameCount + 1;
                numAnts = numAnts + eggsCollected;
                remainingEggs = remainingEggs - eggsCollected;
            }
        }
        
        var framesToWinFocusingOnEggs = CountFramesToWinFocusingOnEggs(0, target, _gameState.MyAntCount, totalEggs);
        var framesToWinFocusingOnCrystals = target / (_gameState.MyAntCount / averageCrystalDist);
        
        if (framesToWinFocusingOnEggs < framesToWinFocusingOnCrystals)
        {
            _gameState.Strategy = StrategyType.CollectEggs;
            _gameState.StrategyStrength = framesToWinFocusingOnCrystals / (framesToWinFocusingOnEggs + framesToWinFocusingOnCrystals);
            Console.Error.WriteLine($"Strategy: CollectEggs ({_gameState.StrategyStrength})");
        }
        else
        {
            _gameState.Strategy = StrategyType.CollectCrystals;
            _gameState.StrategyStrength = framesToWinFocusingOnEggs / (framesToWinFocusingOnEggs + framesToWinFocusingOnCrystals);
            Console.Error.WriteLine($"Strategy: CollectCrystals ({_gameState.StrategyStrength})");
        }
    }

    private float Clamp(float minValue, float maxValue, float value) => Math.Max(minValue, Math.Min(maxValue, value));
}}

// Strategy/StrategyCostBenefitAdaptive.cs
namespace CodinGame_Spring_Challenge_2023.Strategy{
public class StrategyCostBenefitAdaptive
{
    private GameState _gameState;
    private PathFinder _pathFinder;
    private readonly ShortestTree _shortestTree;

    //private List<int> _currentlyVisiting = new();

    public StrategyCostBenefitAdaptive(GameState gameState, PathFinder pathFinder,
        ShortestTree shortestTree)
    {
        _gameState = gameState;
        _pathFinder = pathFinder;
        _shortestTree = shortestTree;
    }

    public static float CalculatePotentialBenefit(
        List<(int index, float resources)> crystalResources,
        List<(int index, float resources)> eggResources,
        float myPotentialAnts,
        int numActualAnts,
        int numLocations,
        int numFrames,
        float enemyPotentialConsumeRate)
    {
        if (numFrames == 0)
        {
            return 0;
        }

        if (numLocations > numActualAnts)
        {
            return -1000;
        }

        if (crystalResources.Sum(x => x.resources) == 0)
        {
            return 0;
        }

        var averageAntsPerLocation = myPotentialAnts / numLocations;
        if (eggResources.Count == 0)
        {
            return crystalResources.Sum(x => Math.Min(x.resources, numFrames * averageAntsPerLocation));
        }

        var newEggResources = eggResources
            .Select(x => (x.index, resources: Math.Max(0, x.resources - averageAntsPerLocation))).ToList();
        var newCrystalResources = crystalResources
            .Select(x => (x.index, resources: Math.Max(0, x.resources - averageAntsPerLocation))).ToList();

        var eggsConsumed = newEggResources.Sum(x => Math.Min(x.resources, averageAntsPerLocation));
        var crystalsConsumed = newCrystalResources.Sum(x => Math.Min(x.resources, averageAntsPerLocation));

        var myNewAnts = myPotentialAnts + eggsConsumed;

        return 0.2f * enemyPotentialConsumeRate + crystalsConsumed + CalculatePotentialBenefit(
            newCrystalResources,
            newEggResources,
            myNewAnts,
            numActualAnts,
            numLocations,
            numFrames - 1,
            enemyPotentialConsumeRate);
    }

    private OneOf<(int cost, float benefit), Invalid> CostBenefit(
        List<int> currentlyVisiting,
        List<int> enemyLocations,
        int potentialLocation,
        bool isEgg,
        int currentNumAnts,
        int enemyNumAnts,
        int lookAhead)
    {
        var enemyDistances = 0;
        if (!enemyLocations.Contains(potentialLocation))
        {
            enemyDistances = _pathFinder.ClosestOrDefault(potentialLocation, enemyLocations)
                .Match(found => found.dist, _ => 5);
        }

        var enemyPotentialConsumeRate = enemyNumAnts / (enemyLocations.Count + enemyDistances);

        var myVisitedEggLocations = currentlyVisiting
            .Select(index => (index, resources: (float)_gameState.Cells[index].Resources))
            .Where(x => _gameState.EggLocations.Contains(x.index))
            .ToList();
        var myVisitedCrystalLocations =
            currentlyVisiting.Select(index => (index, resources: (float)_gameState.Cells[index].Resources))
                .Where(x => _gameState.CrystalLocations.Contains(x.index))
                .ToList();

        var currentBenefit = CalculatePotentialBenefit(myVisitedCrystalLocations,
            myVisitedEggLocations,
            currentNumAnts,
            _gameState.MyAntCount,
            currentlyVisiting.Count, lookAhead, enemyPotentialConsumeRate);

        return _pathFinder.ClosestOrDefault(potentialLocation, currentlyVisiting)
            .Match<OneOf<(int cost, float benefit), Invalid>>(
                found =>
                {
                    var updatedCrystalResourcesVisited = myVisitedCrystalLocations.ToList();
                    var updatedEggsResourcesVisited = myVisitedEggLocations.ToList();
                    (isEgg ? ref updatedEggsResourcesVisited : ref updatedCrystalResourcesVisited).Add((
                        potentialLocation,
                        resources: _gameState.Cells[potentialLocation].Resources));

                    var updatedBenefit = CalculatePotentialBenefit(updatedCrystalResourcesVisited,
                        updatedEggsResourcesVisited, currentNumAnts, _gameState.MyAntCount,
                        currentlyVisiting.Count + found.dist, lookAhead, enemyPotentialConsumeRate);

                    var adjustedFactor = isEgg == (_gameState.Strategy == StrategyType.CollectEggs)
                        ? _gameState.StrategyStrength
                        : 1f - _gameState.StrategyStrength;

                    /*
                    if (isEgg)
                    {
                        Console.Error.WriteLine(
                            $"CostBenefit for location {potentialLocation} Eggs: {_gameState.Cells[potentialLocation].Resources} (adjust: {adjustedFactor}) (dist: {found.index}=>{found.dist}) = {currentBenefit} -> {updatedBenefit}");
                    }
                    else
                    {
                        Console.Error.WriteLine(
                            $"CostBenefit for location {potentialLocation} Crystals: {_gameState.Cells[potentialLocation].Resources} (adjust: {adjustedFactor}) (dist: {found.index}=>{found.dist}) = {currentBenefit} -> {updatedBenefit}");
                    }
                    */

                    return (found.dist, (updatedBenefit - currentBenefit) * adjustedFactor);
                },
                _ => new Invalid());
    }

    public IEnumerable<int> Update(int projectedTurnsUntilGameEnds)
    {
        /*
         *
                    var startLocations = _gameState.MyBaseLocations;

                    if (startLocations.Count > 1)
                    {
                        //We want connections between the bases 
                        var firstLocation = startLocations.First();
                        startLocations.RemoveAt(0);
                        startLocations = ShortestTreeWalker
                            .WalkShortestTree(_gameState, _pathFinder,
                                _shortestTree.GetShortestTree(new List<int> { firstLocation }, startLocations)).ToList();
                    }
         * 
         */


        Console.Error.WriteLine("Strategy: Projected Turns Until Game Ends: " + projectedTurnsUntilGameEnds);
        var currentlyVisiting = _gameState.MyBaseLocations.ToList();
        while (true)
        {
            Console.Error.WriteLine("Strategy: Currently visiting: " + string.Join(",", currentlyVisiting));
            var potentialLocations = _gameState.CrystalLocations.Select(index => (index, isEgg: false)).ToList();
            var myVisitedEggLocations = currentlyVisiting
                .Select(index => (index, resources: (float)_gameState.Cells[index].Resources))
                .Where(x => _gameState.EggLocations.Contains(x.index))
                .ToList();
            var myVisitedCrystalLocations =
                currentlyVisiting.Select(index => (index, resources: (float)_gameState.Cells[index].Resources))
                    .Where(x => _gameState.CrystalLocations.Contains(x.index))
                    .ToList();

            //if (!myVisitedEggLocations.Any())
            {
                potentialLocations.AddRange(_gameState.EggLocations.Select(index => (index, isEgg: true)));
            }

            var enemyLocations = _gameState.Cells.Select((cell, index) => (index, cell.NumEnemyAnts))
                .Where(x => x.NumEnemyAnts > 0).Select(x => x.index).ToList();

            potentialLocations.RemoveAll(x => currentlyVisiting.Contains(x.index));

            var myLocationsWithAnts = _gameState.Cells.Select((cell, index) => (index, cell.NumMyAnts))
                .Where(x => x.NumMyAnts > 0).Select(x => x.index).ToList();
            Console.Error.WriteLine("Strategy: Currently visiting (ants): " + string.Join(",", myLocationsWithAnts));
            Console.Error.WriteLine("Strategy: myVisitedEggLocations: " +
                                    string.Join(",", myVisitedEggLocations.Select(x => $"({x.index}, {x.resources})")));
            Console.Error.WriteLine("Strategy: myVisitedCrystalLocations: " + string.Join(",",
                myVisitedCrystalLocations.Select(x => $"({x.index}, {x.resources})")));
            Console.Error.WriteLine("Strategy: Enemy visiting (ants): " + string.Join(",", enemyLocations));
            Console.Error.WriteLine("Strategy: Currently visiting (ants): " + string.Join(",", myLocationsWithAnts));

            var costBenefits = potentialLocations.Select(x => (
                    x.index,
                    costBenefit: CostBenefit(
                        myLocationsWithAnts, //currentlyVisiting,
                        enemyLocations,
                        x.index,
                        x.isEgg,
                        _gameState.MyAntCount,
                        _gameState.EnemyAntCount,
                        projectedTurnsUntilGameEnds)))
                .Where(x => x.costBenefit.IsValue1)
                .Select(x => (x.index, costBenefit: x.costBenefit.Value1))
                .OrderBy(x => -x.costBenefit.benefit).ToList();

            if (costBenefits.Any())
            {
                foreach (var result in costBenefits)
                {
                    Console.Error.WriteLine(
                        $"Strategy: Cost of going to {result.index} is {result.costBenefit.cost} and benefit is {result.costBenefit.benefit}");
                }

                var first = costBenefits.First();
                if (first.costBenefit.benefit > .5f ||
                    (myVisitedCrystalLocations.Count == 0 && myVisitedEggLocations.Count == 0))
                {
                    //Console.Error.WriteLine($"Strategy: Cost of going to {first.index} is {first.costBenefit.cost} and benefit is {first.costBenefit.benefit}");
                    var locations = myVisitedEggLocations.Select(x => x.index)
                        .Concat(myVisitedCrystalLocations.Select(x => x.index)).Concat(new[] { first.index });
                    currentlyVisiting = ShortestTreeWalker
                        .WalkShortestTree(_gameState, _pathFinder,
                            _shortestTree.GetShortestTree(_gameState.MyBaseLocations, locations)).ToList();
                    continue;
                }
            }

            break;
        }

        return currentlyVisiting;

        //WFC of all possible states? We consider if we add each one and the cost/benefit.
        //AStar search maybe or all possible states and then we pick the best one?
        //Each addition takes away from the rest, so we look to find optimal


        /*
        var totalAnts = _gameState.MyAntCount;

        var locationsIncludedInStrategy = new HashSet<int>();
        var projectedEggCollection = 0;
        var projectedCrystalCollection = 0;

        var orderedLocations = _pathFinder.OrderedPairs(
            _gameState,
            _gameState.MyBaseLocations,
            (_gameState.EggLocations, CellType.Eggs),
            (_gameState.CrystalLocations, CellType.Crystal));

        foreach (var (fromIndex, toIndex, dist, cellType) in orderedLocations)
        {
            switch (cellType)
            {
                case CellType.Crystal:
                {
                    
                    break;
                }

                case CellType.Eggs:
                {
                    
                    
                    break;
                }
            }
        }
        return _gameState.MyBaseLocations;
        */
    }
}}

// PathFinding/MapInfo.cs
namespace CodinGame_Spring_Challenge_2023.PathFinding{
public class MapInfo
{
    private GameState _gameState;
    private PathFinder _pathFinder;

    public List<CellMapInfoDynamic> CellMapInfoDynamic { get; } = new();
    public List<CellMapInfoStatic> CellMapInfoStatic { get; } = new();

    public MapInfo(GameState gameState, PathFinder pathFinder)
    {
        _gameState = gameState;
        _pathFinder = pathFinder;
    }
    
    public void UpdateStatic()
    {
        if (CellMapInfoStatic.Count > 0) return;
        
        for (var i = 0; i < _gameState.NumberOfCells; ++i)
        {
            var cellMapInfoStatic = new CellMapInfoStatic
            {
                MyClosestBase = -1,
                EnemyClosestBase = -1
            };

            var closestDistances = _pathFinder.ClosestDistances(i, _gameState.MyBaseLocations);
            if (closestDistances.Any())
            {
                cellMapInfoStatic.MyClosestBase = closestDistances.First().index;
            }

            closestDistances = _pathFinder.ClosestDistances(i, _gameState.EnemyBaseLocations);
            if (closestDistances.Any())
            {
                cellMapInfoStatic.EnemyClosestBase = closestDistances.First().index;
            }
            
            CellMapInfoStatic.Add(cellMapInfoStatic);
            CellMapInfoDynamic.Add(new CellMapInfoDynamic());
        }
    }
    
    public void UpdateDynamic()
    {
        for (var i = 0; i < _gameState.NumberOfCells; ++i)
        {
            CellMapInfoDynamic[i].Resources = _gameState.Cells[i].Resources;
        }
    }
    
    public (CellMapInfoStatic staticInfo, CellMapInfoDynamic dynamicInfo) GetCellInfo(int cellIndex)
    {
        return (CellMapInfoStatic[cellIndex], CellMapInfoDynamic[cellIndex]);
    }
}

public record CellMapInfoStatic
{
    public int MyClosestBase;
    public int EnemyClosestBase;
}

public record CellMapInfoDynamic
{
    public int Resources;
}}

// PathFinding/PathFinder.cs
namespace CodinGame_Spring_Challenge_2023.PathFinding{
public class PathFinder
{
    private readonly int _numCells;

    private readonly List<Dictionary<int, (OneOrMany<int> dir, int dist)>> _cellPathMap =
        new();

    private bool _fullyExpanded;

    private Action _onPathExpansionComplete;

    public PathFinder(GameState gameState)
    {
        _numCells = gameState.NumberOfCells;
        _onPathExpansionComplete = () => { };

        BuildPathInfo(gameState);
    }

    public PathFinder(List<Dictionary<int, (OneOrMany<int> dir, int dist)>> cellPathMap, int numCells)
    {
        _numCells = numCells;
        _cellPathMap = cellPathMap;
        _onPathExpansionComplete = () => { };
    }

    public void OnPathExpansionComplete(Action action)
    {
        _onPathExpansionComplete = action;
    }

    public bool ExpandPathKnowledge()
    {
        if (_fullyExpanded) return true;

        var newPathsFound = new List<(int from, int fromDir, int to, OneOrMany<int> toDir, int dist)>();

        for (var i = 0; i < _numCells; ++i)
        {
            var pathsForCell = _cellPathMap[i];

            foreach (var knownCellIndex in pathsForCell.Keys)
            {
                var pathToKnownCell = pathsForCell[knownCellIndex];
                var pathsForKnownCell = _cellPathMap[knownCellIndex];
                foreach (var otherCellIndex in pathsForKnownCell.Keys)
                {
                    if (i == otherCellIndex) continue;

                    var possibleDistViaKnownCell = pathToKnownCell.dist + pathsForKnownCell[otherCellIndex].dist;

                    if (pathsForCell.TryGetValue(otherCellIndex, out var myCurrentBestPathToOtherCell))
                    {
                        if (myCurrentBestPathToOtherCell.dist < possibleDistViaKnownCell)
                        {
                            continue;
                        }

                        if (myCurrentBestPathToOtherCell.dist == possibleDistViaKnownCell)
                        {
                            var currentDir = myCurrentBestPathToOtherCell.dir;
                            var addNewDir = _cellPathMap[otherCellIndex][knownCellIndex].dir;
                            if (currentDir.IsEquivalent(addNewDir)) continue;
                            
                            var mergedPathDirs = currentDir.Merge(addNewDir);

                            newPathsFound.Add((i, pathToKnownCell.dir, otherCellIndex, mergedPathDirs,
                                possibleDistViaKnownCell));

                            continue;
                        }
                    }

                    //We are new here or simply have a better path!
                    var pathsForOtherCell = _cellPathMap[otherCellIndex];
                    newPathsFound.Add((i, pathToKnownCell.dir, otherCellIndex, pathsForOtherCell[knownCellIndex].dir,
                        possibleDistViaKnownCell));
                }
            }
        }

        if (newPathsFound.Count == 0)
        {
            _fullyExpanded = true;
            _onPathExpansionComplete();
            return true;
        }

        foreach (var newPath in newPathsFound)
        {
            _cellPathMap[newPath.from][newPath.to] = (newPath.fromDir, newPath.dist);
            _cellPathMap[newPath.to][newPath.from] = (newPath.toDir, newPath.dist);
        }

        return false;
    }


    private void BuildPathInfo(GameState gameState)
    {
        for (var i = 0; i < gameState.NumberOfCells; ++i)
        {
            var pathsForCell = new Dictionary<int, (OneOrMany<int> dir, int dist)>();
            _cellPathMap.Add(pathsForCell);

            var cell = gameState.Cells[i];
            for (var dir = 0; dir < 6; ++dir)
            {
                var neighbourIndex = cell.Neighbours[dir];
                if (neighbourIndex == -1) continue;

                pathsForCell.Add(neighbourIndex, (dir, 1));
            }
        }
    }
    /*
for (var i = 0; i < _gameState.NumberOfCells; ++i)
    {
        var cell = _gameState.Cells[i];
        var pathsForCell = _cellPathMap[i];

        foreach (var pathToIndex in pathsForCell.Keys)
        {
            var knownCell = _gameState.Cells[pathToIndex];
            var pathsForKnownCell = _cellPathMap[pathToIndex];
            foreach (var otherPathToIndex in pathsForCell.Keys)
            {
                if (pathToIndex == otherPathToIndex) continue;

                if (!pathsForKnownCell.ContainsKey(otherPathToIndex))
                {
                    pathsForKnownCell[otherPathToIndex] = pathsForCell[pathToIndex].
                }   
            }
        }
    }
}
*/

    public IOrderedEnumerable<(int index, int dist)> ClosestDistances(int fromIndex, IEnumerable<int> toIndexList) =>
        toIndexList.Select(index => (index, dist: Distance(fromIndex, index))).Where((_, dist) => dist > -1)
            .OrderBy(x => x.dist);

    public OneOf<(int index, int dist), NotFound> ClosestOrDefault(int fromIndex, IEnumerable<int> toIndexList)
    {
        var closestDistances = ClosestDistances(fromIndex, toIndexList);
        if (closestDistances.Any())
        {
            return closestDistances.First();
        }

        return new NotFound();
    }

    public int Distance(int fromIndex, int toIndex)
    {
        if (_cellPathMap[fromIndex].TryGetValue(toIndex, out var path))
        {
            return path.dist;
        }

        return -1;
    }

    public IEnumerable<int> PathTo(GameState gameState, int fromIndex, int toIndex)
    {
        if (!_cellPathMap[fromIndex].ContainsKey(toIndex))
        {
            return Enumerable.Empty<int>();
        }

        var path = new List<int>();
        var currentCellIndex = fromIndex;
        while (currentCellIndex != toIndex)
        {
            path.Add(currentCellIndex);
            var nextCellDir = _cellPathMap[currentCellIndex][toIndex].dir;
            currentCellIndex = gameState.Cells[currentCellIndex].Neighbours[nextCellDir];
        }

        path.Add(toIndex);
        return path;
    }

    public IEnumerable<int> ClosestNOf(GameState gameState, int num, params IEnumerable<int>[] indexLists)
    {
        var closest = new List<int>();
        var closestDistances = new List<int>();
        foreach (var indexList in indexLists)
        {
            foreach (var index in indexList)
            {
                var dist = Distance(gameState.MyBases[0].CellIndex, index);
                if (dist == -1) continue;

                var indexToInsertAt = closestDistances.FindIndex(d => d > dist);
                if (indexToInsertAt == -1)
                {
                    indexToInsertAt = closest.Count;
                }

                closest.Insert(indexToInsertAt, index);
                closestDistances.Insert(indexToInsertAt, dist);
            }
        }

        return closest.Take(num);
    }

    public IOrderedEnumerable<(int fromIndex, int toIndex, int dist, CellType cellType)> OrderedPairs(
        GameState gameState,
        IEnumerable<int> fromList, params (IEnumerable<int>, CellType)[] indexLists)
    {
        var orderedPairs = (
            from fromIndex in fromList
            from list in indexLists
            from toIndex in list.Item1
            select (fromIndex, toIndex, dist: Distance(fromIndex, toIndex), cellType: list.Item2)
        ).ToList();

        return orderedPairs.OrderBy(x => x.dist);
    }

    public string DebugDistances(GameState gameState)
    {
        var output = "Distances from my base: ";
        foreach (var myBase in gameState.MyBases)
        {
            var crystalDistances = ClosestDistances(myBase.CellIndex, gameState.CrystalLocations);
            foreach (var crystal in crystalDistances)
            {
                output += $"({crystal.index}, {crystal.dist}) ";
            }
        }

        output += " Distances from enemy base: ";
        foreach (var enemyBase in gameState.EnemyBases)
        {
            var crystalDistances = ClosestDistances(enemyBase.CellIndex, gameState.CrystalLocations);
            foreach (var crystal in crystalDistances)
            {
                output += $"({crystal.index}, {crystal.dist}) ";
            }
        }

        return output;
    }

    public string DebugPaths(GameState gameState)
    {
        var output = "Paths from my base: ";
        foreach (var myBase in gameState.MyBases)
        {
            foreach (var crystal in gameState.CrystalLocations)
            {
                var path = PathTo(gameState, myBase.CellIndex, crystal);
                output += $"(Base({myBase.CellIndex}) -> Crystal({crystal}) : ";
                foreach (var step in path)
                {
                    output += step + " ";
                }
            }
        }

        output += " Paths from enemy base: ";
        foreach (var enemyBase in gameState.EnemyBases)
        {
            foreach (var crystal in gameState.CrystalLocations)
            {
                var path = PathTo(gameState, enemyBase.CellIndex, crystal);
                output += $"(Base({enemyBase.CellIndex}) -> Crystal({crystal}) : ";
                foreach (var step in path)
                {
                    output += step + " ";
                }
            }
        }

        return output;
    }

    public OneOf<IList<int>, IList<IList<int>>> Paths(GameState gameState, int fromIndex, int toIndex)
    {
        if (fromIndex == toIndex)
        {
            return new List<int> { fromIndex };
        }

        if (!_cellPathMap[fromIndex].TryGetValue(toIndex, out var pathHeading))
        {
            return new List<int>();
        }

        IList<int> BuildPath(int startIndex, IList<int> onwardPath)
        {
            onwardPath.Insert(0, startIndex);
            return onwardPath;
        }

        OneOf<IList<int>, IList<IList<int>>> FollowPath(int dir) => Paths(
                gameState,
                gameState.Cells[fromIndex].Neighbours[dir],
                toIndex)
            .Match(
                singlePath => new OneOf<IList<int>, IList<IList<int>>>(BuildPath(fromIndex, singlePath)),
                multiplePaths => multiplePaths.Select(path => BuildPath(fromIndex, new List<int>(path))).ToList()
            );

        return pathHeading.dir.Match(
            singleDir => FollowPath(singleDir),
            multipleDirs =>
            {
                var paths = new List<IList<int>>();
                foreach (var dir in multipleDirs)
                {
                    FollowPath(dir).Match(
                        singlePath => paths.Add(singlePath),
                        multiplePaths => paths.AddRange(multiplePaths));
                }

                return paths;
            });
    }
}}

// PathFinding/ShortestTree.cs
namespace CodinGame_Spring_Challenge_2023.PathFinding
{
    public class ShortestTree
    {
        private PathFinder _pathFinder;
        
        public ShortestTree(PathFinder pathFinder)
        {
            _pathFinder = pathFinder;
        }
        
        public IEnumerable<(int fromIndex, int toIndex)> GetShortestTree(IEnumerable<int> startLocations, IEnumerable<int> includeLocations)
        {
            var shortestTree = new List<(int fromIndex, int toIndex)>();
            
            var visited = new HashSet<int>();
            var unvisited = new HashSet<int>();
            foreach (var index in startLocations)
            {
                visited.Add(index);
            }
            
            foreach (var index in includeLocations)
            {
                unvisited.Add(index);
            }
            
            while (unvisited.Count > 0)
            {
                var shortestPath = (fromIndex: -1, toIndex: -1, dist: int.MaxValue);
                foreach (var visitedCellIndex in visited)
                {
                    foreach (var unvisitedCellIndex in unvisited)
                    {
                        var dist = _pathFinder.Distance(unvisitedCellIndex, visitedCellIndex);
                        if (dist < 0) continue;
                        
                        if (dist < shortestPath.dist)
                        {
                            shortestPath = (visitedCellIndex, unvisitedCellIndex, dist);
                        }
                    }
                }
                
                shortestTree.Add((shortestPath.fromIndex, shortestPath.toIndex));
                
                visited.Add(shortestPath.toIndex);
                unvisited.Remove(shortestPath.toIndex);
            }
            
            return shortestTree;
        }
    }
}

// PathFinding/ShortestTreeWalker.cs
namespace CodinGame_Spring_Challenge_2023.PathFinding
{
    public static class ShortestTreeWalker
    {
        public static IEnumerable<int> WalkShortestTree(GameState gameState, PathFinder pathFinder,
            IEnumerable<(int fromIndex, int toIndex)> tree) => tree
            .SelectMany(x => pathFinder.PathTo(gameState, x.fromIndex, x.toIndex)).Distinct();
    }
}
